use std::{collections::BTreeMap, ffi::OsString, error::Error, io::Cursor};

use bytekind::{Bytes, HexString};
use clap::builder::OsStr;
use hex::FromHexError;
use microtype::microtype;
use serde::{Deserialize, Deserializer, Serialize, Serializer};

pub(crate) mod arbitrary;
mod cbor;
// mod crypto;
pub use crypto2::{PubKey, Sig};
mod crypto2;
// pub use crypto::{PubKey, Sig};
pub mod hex_bytes;
mod network_id;
pub use network_id::NetworkId;
use test_strategy::Arbitrary;

/// The source of voting power for a given registration
///
/// The voting power can either come from:
///  - a single wallet, OR
///  - a set of delegations
#[derive(Serialize, Deserialize)]
#[serde(untagged)]
#[derive(Debug, Clone, PartialEq)]
pub enum VotingKey {
    /// Direct voting
    ///
    /// Voting power is based on the staked ada of the given key
    Direct(VotingKeyHex),

    /// Delegated voting
    ///
    /// Voting power is based on the staked ada of the delegated keys
    #[serde(serialize_with = "serialize_btree_as_vec_tuple")]
    #[serde(deserialize_with = "deserialize_btree_as_vec_tuple")]
    Delegated(BTreeMap<VotingKeyHex, u64>),
}

fn deserialize_btree_as_vec_tuple<'de, D: Deserializer<'de>>(
    d: D,
) -> Result<BTreeMap<VotingKeyHex, u64>, D::Error> {
    <Vec<(VotingKeyHex, u64)>>::deserialize(d).map(|vec| vec.into_iter().collect())
}

fn serialize_btree_as_vec_tuple<S: Serializer>(
    map: &BTreeMap<VotingKeyHex, u64>,
    s: S,
) -> Result<S::Ok, S::Error> {
    let vec: Vec<_> = map.iter().collect();
    vec.serialize(s)
}

impl VotingKey {
    /// Create a direct voting power source from a hex string representing a voting key
    ///
    /// # Errors
    ///
    /// Returns an error if `s` is not a hex string representing an array of 32 bytes (i.e. a 64
    /// character string)
    #[inline]
    pub fn direct_from_hex(s: &str) -> Result<Self, FromHexError> {
        let bytes = hex::decode(s)?;
        Ok(Self::Direct(PubKey(bytes).into()))
    }
}

/// A catalyst registration on Cardano in either CIP-15 or CIP-36 format
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct Registration {
    #[serde(rename = "1")]
    pub voting_key: VotingKey,
    #[serde(rename = "2")]
    pub stake_key: StakeKeyHex,
    #[serde(rename = "3")]
    pub rewards_address: RewardsAddress,
    // note, this must be monotonically increasing. Typically, the current slot
    // number is used
    #[serde(rename = "4")]
    pub nonce: Nonce,
    #[serde(rename = "5")]
    pub voting_purpose: Option<VotingPurpose>,
}

/// Struct for deserializing the binary registration from dbsync
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct BinRegistration {
    #[serde(rename = "61284")]
    pub registration: Registration,
}


/// A signature for a registration as defined in CIP-15
///
/// This is compatible with CIP-36 registrations
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct Signature {
    /// The actual signature
    ///
    /// CIP-15 specifies this must be a field, so an extra layer of nesting is required
    #[serde(rename = "1")]
    pub inner: Sig,
}

/// Struct for deserializing the binary registration sig from dbsync
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct BinSignature {
    #[serde(rename = "61285")]
    pub signature: Signature,
}

/// A Catalyst registration in either CIP-15 or CIP-36 format, along with its signature
///
/// The signature is generated by:
///  - CBOR encoding the registration as a single entry map with a key of `61284` and a value of
///  the registration
///  - Hashing the bytes of the CBOR encoding with `blake2b_256`
///  - Signing the hash with the public key
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct SignedRegistration {
    /// The registration
    #[serde(rename = "61284")]
    pub registration: Registration,
    /// The signature
    #[serde(rename = "61285")]
    pub signature: Signature,

    /// Stake Key Hash
    pub stake_key_hash: <blah>,

    /// The id of the transaction that created this registration
    pub tx_id: TxId,

    /// The slot the registration was found in.
    pub slot: u64,

    /// Raw Staked ADA
    pub staked_ada: Option<u128>,
}

/// A Raw Registration from the DB.
///
#[derive(Debug, Clone)]
pub struct RawRegistration {

    /// cip 15/36: 61284 json from DB.
    pub json_reg: serde_json::Value,

    /// cip 15/36: 61285 json from DB.
    pub json_sig: serde_json::Value,

    /// cip 15/36: 61284 raw binary
    pub bin_reg: Vec<u8>,

    /// cip 15/36: 61285 raw binary
    pub bin_sig: Vec<u8>,

    /// registration tx_id
    pub tx_id: TxId,

    /// The slot the registration was found in.
    pub slot: u64,
}

pub struct RegistrationValidationOptions {
    pub rewards_address: bool,
}

impl RawRegistration {
    pub fn to_signed(&self) -> Result<SignedRegistration, Box<dyn Error>> {
        let decoded_reg: BinRegistration = ciborium::de::from_reader(Cursor::new(&self.bin_reg))?;
        let decoded_sig: BinSignature = ciborium::de::from_reader(Cursor::new(&self.bin_sig))?;

        Ok(SignedRegistration {
            registration: decoded_reg.registration,
            signature: decoded_sig.signature,
            tx_id: self.tx_id,
            slot: self.slot,
        })
    }
}

/// Single element in a snapshot
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct SnapshotEntry {
    /// Registration content
    #[serde(rename = "delegations")]
    pub voting_key: VotingKey,

    /// Mainnet rewards address
    pub rewards_address: RewardsAddress,

    /// Stake public key
    #[serde(rename = "stake_public_key")]
    pub stake_key: StakeKeyHex,

    /// Voting power expressed in ada
    ///
    /// This is computed from `voting_key`
    pub voting_power: u128,

    /// Voting purpose
    ///
    /// Catalyst expects the voting purpose is set to `0`
    pub voting_purpose: Option<VotingPurpose>,

    /// Registration transaction id
    pub tx_id: TxId,
}

// Create newtype wrappers for better type safety
microtype! {
    #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Arbitrary)]
    pub PubKey {
        VotingKeyHex,
        StakeKeyHex,
    }


    #[derive(Debug, PartialEq, Clone)]
    #[string]
    pub String {
        /// Database name
        DbName,
        /// Database user
        DbUser,
        /// Database host
        DbHost,
        StakeAddr,
        StakePubKey,
    }

    #[secret]
    #[string]
    pub String {
        /// Database password
        DbPass,
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default, Arbitrary)]
    #[int]
    pub u64 {
        Nonce,
        /// A slot number
        SlotNo,

        /// A `u64` used to identify the purpose of a particular registration
        ///
        /// `0` is used for catalyst voting
        VotingPurpose,
        TxId,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub Bytes<HexString> {
        /// A rewards address in a catalyst registation
        ///
        /// This type deliberately does not enforce a particular format for addresses, since the
        /// spec only requires this field to be a byte array, with no other constraints
        RewardsAddress,
    }
}

impl VotingPurpose {
    /// The voting purpose for catalyst registrations
    pub const CATALYST: VotingPurpose = VotingPurpose(0);
}

impl From<VotingPurpose> for OsStr {
    fn from(purpose: VotingPurpose) -> Self {
        OsStr::from(OsString::from(purpose.to_string()))
    }
}

impl From<NetworkId> for OsStr {
    fn from(id: NetworkId) -> Self {
        OsStr::from(match id {
            NetworkId::Mainnet => "mainnet",
            NetworkId::Testnet => "testnet",
        })
    }
}

impl SlotNo {
    /// Attempt to convert this to an `i64`
    ///
    /// Returns none if the underlying `u64` doesn't fit into an `i64`
    #[inline]
    #[must_use]
    pub fn into_i64(self) -> Option<i64> {
        self.0.try_into().ok()
    }
}

impl RewardsAddress {
    /// Decode a [`RewardsAddress`] from a hex string
    ///
    /// Errors if the string is not valid hex
    ///
    /// ```
    /// # use crate::data::RewardsAddress;
    /// let address = RewardsAddress::from_hex("0000").unwrap();
    /// assert_eq!(address.0, vec![0, 0]);
    /// ```
    #[inline]
    pub fn from_hex(s: &str) -> Result<Self, FromHexError> {
        let bytes = hex::decode(s)?;
        Ok(Self(bytes.into()))
    }
}

macro_rules! hex_impls {
    ($t:ty) => {
        impl core::fmt::Display for $t {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "0x{}", hex::encode(&self.0))
            }
        }

        impl AsRef<[u8]> for $t {
            fn as_ref(&self) -> &[u8] {
                self.0.as_ref()
            }
        }
    };
}

hex_impls!(VotingKeyHex);
hex_impls!(StakeKeyHex);
