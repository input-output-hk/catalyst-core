/*
 * Catalyst 1.0
 *
 * Revised API expressing all capabilities of the Catalyst 1.0 Backend.  TODO: * Implement Permissionless Auth. * Implement Replacement Functionality for GVC. * Implement drep registration on main-chain, distinct from voter registration. * Implement Voting API abstracting the Jormungandr API from public exposure. * Implement Audit API's (Retrieve voting blockchain records,  registration/voting power audit and private tally audit. * Implement API's needed to support posting Ideas/Proposals etc.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: steven.johnson@iohk.io
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`get_all_ballot_info_per_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllBallotInfoPerEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_ballot_info_per_objective`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllBallotInfoPerObjectiveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_api_v1_ballot_cast_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApiV1BallotCastIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ballot_info_per_proposal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBallotInfoPerProposalError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ballot_proofs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBallotProofsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_api_v1_ballot_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostApiV1BallotCheckError {
    UnknownValue(serde_json::Value),
}


/// Retrieves all necessary information to cast a vote. If not present, they are not yet defined. If not defined, then it is not possible to cast a ballot on this proposal yet. 
pub async fn get_all_ballot_info_per_event(configuration: &configuration::Configuration, id: serde_json::Value) -> Result<serde_json::Value, Error<GetAllBallotInfoPerEventError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/event/{id}/ballots", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllBallotInfoPerEventError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves all necessary information to cast a vote. If not present, they are not yet defined. If not defined, then it is not possible to cast a ballot on this proposal yet. 
pub async fn get_all_ballot_info_per_objective(configuration: &configuration::Configuration, id: serde_json::Value, obj_id: serde_json::Value) -> Result<serde_json::Value, Error<GetAllBallotInfoPerObjectiveError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/event/{id}/objective/{obj_id}/ballots", local_var_configuration.base_path, id=id, obj_id=obj_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllBallotInfoPerObjectiveError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cast a Ballot on the requested Voting Event.
pub async fn get_api_v1_ballot_cast_id(configuration: &configuration::Configuration, id: serde_json::Value) -> Result<(), Error<GetApiV1BallotCastIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/ballot/cast/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetApiV1BallotCastIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves all necessary information to cast a vote. If not present, they are not yet defined. If not defined, then it is not possible to cast a ballot on this proposal yet. 
pub async fn get_ballot_info_per_proposal(configuration: &configuration::Configuration, id: serde_json::Value, obj_id: serde_json::Value, prop_id: serde_json::Value) -> Result<crate::models::CatalystV1Ballot, Error<GetBallotInfoPerProposalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/event/{id}/objective/{obj_id}/proposal/{prop_id}/ballot", local_var_configuration.base_path, id=id, obj_id=obj_id, prop_id=prop_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBallotInfoPerProposalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get list of details and ballot proofs for every currently cast ballot on a particular voting event for a particular voting key.
pub async fn get_ballot_proofs(configuration: &configuration::Configuration, vkey: serde_json::Value, id: serde_json::Value, votes_by_vote_caster_and_voteplan_id: crate::models::VotesByVoteCasterAndVoteplanId) -> Result<crate::models::VoteInfo, Error<GetBallotProofsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/ballot/proof/{vkey}/{id}", local_var_configuration.base_path, vkey=vkey, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&votes_by_vote_caster_and_voteplan_id);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBallotProofsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check if a Ballot is correctly formatted and signed. This endpoint is to check all possible aspects of an individual ballot and return a report details what is correct, and what is incorrect. The actual format of the report is TBD on implementation. It is to handle both Private and Public Ballots.  If Event ID is provided, the ballot should also be checked against current knowledge of the Events Objectives and Proposals to check the contents of the ballot are correct.  Otherwise, they are not considered and ONLY the raw format is checked.  It must also check the Ballot is signed properly with the voters private voting key.  If an event is supplied, it should also check if the Voting Key is registered and eligible to vote on the event. If no event is supplied, it should check if the \"latest\" snapshot contains a registration for this voting key.  If it does not, this is not an Error, but a warning status should be returned.
pub async fn post_api_v1_ballot_check(configuration: &configuration::Configuration, ) -> Result<(), Error<PostApiV1BallotCheckError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/ballot/check", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostApiV1BallotCheckError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

