"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Challenge`."""
  challenges(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Challenge`."""
    orderBy: [ChallengesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChallengeCondition
  ): ChallengesConnection

  """Reads and enables pagination through a set of `ChallengeCategory`."""
  challengeCategories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ChallengeCategory`."""
    orderBy: [ChallengeCategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChallengeCategoryCondition
  ): ChallengeCategoriesConnection

  """
  Reads and enables pagination through a set of `CommunityAdvisorsReview`.
  """
  communityAdvisorsReviews(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CommunityAdvisorsReview`."""
    orderBy: [CommunityAdvisorsReviewsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommunityAdvisorsReviewCondition
  ): CommunityAdvisorsReviewsConnection

  """Reads and enables pagination through a set of `Config`."""
  configs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Config`."""
    orderBy: [ConfigsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ConfigCondition
  ): ConfigsConnection

  """Reads and enables pagination through a set of `Contribution`."""
  contributions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Contribution`."""
    orderBy: [ContributionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContributionCondition
  ): ContributionsConnection

  """Reads and enables pagination through a set of `Currency`."""
  currencies(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CurrencyCondition
  ): CurrenciesConnection

  """Reads and enables pagination through a set of `Event`."""
  events(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EventCondition
  ): EventsConnection

  """Reads and enables pagination through a set of `Goal`."""
  goals(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Goal`."""
    orderBy: [GoalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GoalCondition
  ): GoalsConnection

  """Reads and enables pagination through a set of `Proposal`."""
  proposals(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Proposal`."""
    orderBy: [ProposalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProposalCondition
  ): ProposalsConnection

  """
  Reads and enables pagination through a set of `ProposalCommunityChoiceChallenge`.
  """
  proposalCommunityChoiceChallenges(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProposalCommunityChoiceChallenge`."""
    orderBy: [ProposalCommunityChoiceChallengesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProposalCommunityChoiceChallengeCondition
  ): ProposalCommunityChoiceChallengesConnection

  """Reads and enables pagination through a set of `ProposalVoteplan`."""
  proposalVoteplans(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProposalVoteplan`."""
    orderBy: [ProposalVoteplansOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProposalVoteplanCondition
  ): ProposalVoteplansConnection

  """Reads and enables pagination through a set of `RefinerySchemaHistory`."""
  refinerySchemaHistories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `RefinerySchemaHistory`."""
    orderBy: [RefinerySchemaHistoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RefinerySchemaHistoryCondition
  ): RefinerySchemaHistoriesConnection

  """Reads and enables pagination through a set of `Snapshot`."""
  snapshots(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Snapshot`."""
    orderBy: [SnapshotsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SnapshotCondition
  ): SnapshotsConnection

  """Reads and enables pagination through a set of `TallyCommittee`."""
  tallyCommittees(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TallyCommittee`."""
    orderBy: [TallyCommitteesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TallyCommitteeCondition
  ): TallyCommitteesConnection

  """Reads and enables pagination through a set of `Vote`."""
  votes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection

  """Reads and enables pagination through a set of `VoteOption`."""
  voteOptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `VoteOption`."""
    orderBy: [VoteOptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteOptionCondition
  ): VoteOptionsConnection

  """Reads and enables pagination through a set of `Voteplan`."""
  voteplans(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Voteplan`."""
    orderBy: [VoteplansOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteplanCondition
  ): VoteplansConnection

  """Reads and enables pagination through a set of `VoteplanCategory`."""
  voteplanCategories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `VoteplanCategory`."""
    orderBy: [VoteplanCategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteplanCategoryCondition
  ): VoteplanCategoriesConnection

  """Reads and enables pagination through a set of `Voter`."""
  voters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Voter`."""
    orderBy: [VotersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoterCondition
  ): VotersConnection

  """Reads and enables pagination through a set of `VotingGroup`."""
  votingGroups(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `VotingGroup`."""
    orderBy: [VotingGroupsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VotingGroupCondition
  ): VotingGroupsConnection

  """Reads and enables pagination through a set of `VotingNode`."""
  votingNodes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `VotingNode`."""
    orderBy: [VotingNodesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VotingNodeCondition
  ): VotingNodesConnection
  challenge(rowId: Int!): Challenge
  challengeCategory(name: String!): ChallengeCategory
  communityAdvisorsReview(rowId: Int!): CommunityAdvisorsReview
  config(rowId: Int!): Config
  contribution(rowId: BigInt!): Contribution
  currency(name: String!): Currency
  event(rowId: Int!): Event
  goal(id: Int!): Goal
  proposal(rowId: Int!): Proposal
  proposalById(id: Int!): Proposal
  proposalVoteplan(rowId: Int!): ProposalVoteplan
  refinerySchemaHistory(version: Int!): RefinerySchemaHistory
  snapshot(rowId: Int!): Snapshot
  snapshotByEvent(event: Int!): Snapshot
  tallyCommittee(rowId: Int!): TallyCommittee
  tallyCommitteeByEvent(event: Int!): TallyCommittee
  vote(rowId: BigInt!): Vote
  voteOption(id: Int!): VoteOption
  voteOptionByIdeaScale(ideaScale: String!): VoteOption
  voteOptionByChallenge(challenge: String!): VoteOption
  voteplan(rowId: Int!): Voteplan
  voteplanById(id: String!): Voteplan
  voteplanCategory(name: String!): VoteplanCategory
  voter(rowId: BigInt!): Voter
  votingGroup(rowId: Int!): VotingGroup
  votingNode(hostname: String!, event: Int!): VotingNode

  """Gets the account identified by our JWT."""
  currentAcct: AdminAccount

  """Reads a single `Challenge` using its globally unique `ID`."""
  challengeByNodeId(
    """The globally unique `ID` to be used in selecting a single `Challenge`."""
    nodeId: ID!
  ): Challenge

  """Reads a single `ChallengeCategory` using its globally unique `ID`."""
  challengeCategoryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ChallengeCategory`.
    """
    nodeId: ID!
  ): ChallengeCategory

  """
  Reads a single `CommunityAdvisorsReview` using its globally unique `ID`.
  """
  communityAdvisorsReviewByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CommunityAdvisorsReview`.
    """
    nodeId: ID!
  ): CommunityAdvisorsReview

  """Reads a single `Config` using its globally unique `ID`."""
  configByNodeId(
    """The globally unique `ID` to be used in selecting a single `Config`."""
    nodeId: ID!
  ): Config

  """Reads a single `Contribution` using its globally unique `ID`."""
  contributionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Contribution`.
    """
    nodeId: ID!
  ): Contribution

  """Reads a single `Currency` using its globally unique `ID`."""
  currencyByNodeId(
    """The globally unique `ID` to be used in selecting a single `Currency`."""
    nodeId: ID!
  ): Currency

  """Reads a single `Event` using its globally unique `ID`."""
  eventByNodeId(
    """The globally unique `ID` to be used in selecting a single `Event`."""
    nodeId: ID!
  ): Event

  """Reads a single `Goal` using its globally unique `ID`."""
  goalByNodeId(
    """The globally unique `ID` to be used in selecting a single `Goal`."""
    nodeId: ID!
  ): Goal

  """Reads a single `Proposal` using its globally unique `ID`."""
  proposalByNodeId(
    """The globally unique `ID` to be used in selecting a single `Proposal`."""
    nodeId: ID!
  ): Proposal

  """Reads a single `ProposalVoteplan` using its globally unique `ID`."""
  proposalVoteplanByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ProposalVoteplan`.
    """
    nodeId: ID!
  ): ProposalVoteplan

  """Reads a single `RefinerySchemaHistory` using its globally unique `ID`."""
  refinerySchemaHistoryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `RefinerySchemaHistory`.
    """
    nodeId: ID!
  ): RefinerySchemaHistory

  """Reads a single `Snapshot` using its globally unique `ID`."""
  snapshotByNodeId(
    """The globally unique `ID` to be used in selecting a single `Snapshot`."""
    nodeId: ID!
  ): Snapshot

  """Reads a single `TallyCommittee` using its globally unique `ID`."""
  tallyCommitteeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TallyCommittee`.
    """
    nodeId: ID!
  ): TallyCommittee

  """Reads a single `Vote` using its globally unique `ID`."""
  voteByNodeId(
    """The globally unique `ID` to be used in selecting a single `Vote`."""
    nodeId: ID!
  ): Vote

  """Reads a single `VoteOption` using its globally unique `ID`."""
  voteOptionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `VoteOption`.
    """
    nodeId: ID!
  ): VoteOption

  """Reads a single `Voteplan` using its globally unique `ID`."""
  voteplanByNodeId(
    """The globally unique `ID` to be used in selecting a single `Voteplan`."""
    nodeId: ID!
  ): Voteplan

  """Reads a single `VoteplanCategory` using its globally unique `ID`."""
  voteplanCategoryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `VoteplanCategory`.
    """
    nodeId: ID!
  ): VoteplanCategory

  """Reads a single `Voter` using its globally unique `ID`."""
  voterByNodeId(
    """The globally unique `ID` to be used in selecting a single `Voter`."""
    nodeId: ID!
  ): Voter

  """Reads a single `VotingGroup` using its globally unique `ID`."""
  votingGroupByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `VotingGroup`.
    """
    nodeId: ID!
  ): VotingGroup

  """Reads a single `VotingNode` using its globally unique `ID`."""
  votingNodeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `VotingNode`.
    """
    nodeId: ID!
  ): VotingNode
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Challenge` values."""
type ChallengesConnection {
  """A list of `Challenge` objects."""
  nodes: [Challenge!]!

  """
  A list of edges which contains the `Challenge` and cursor to aid in pagination.
  """
  edges: [ChallengesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Challenge` you could get from the connection."""
  totalCount: Int!
}

"""
All Challenges for all events.
A Challenge is a group category for selection in an event.
"""
type Challenge implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic Unique Key"""
  rowId: Int!

  """
  Event specific Challenge ID.
  Can be non-unique between events (Eg, Ideascale ID for challenge).
  """
  id: Int!

  """The specific Event ID this Challenge is part of."""
  event: Int!

  """
  What category of challenge is this.
  See the challenge_category table for allowed values.
  """
  category: String!

  """The  title of the challenge."""
  title: String!

  """Long form description of the challenge."""
  description: String!

  """The currency rewards values are represented as."""
  rewardsCurrency: String

  """The total reward pool to pay on this challenge to winning proposals."""
  rewardsTotal: BigInt

  """Not sure how this is different from rewards_total???"""
  proposersRewards: BigInt

  """The Vote Options applicable to all proposals in this challenge."""
  voteOptions: Int

  """
  Extra Data  for this challenge represented as JSON.
  "url"."challenge" is a URL for more info about the challenge.
  "highlights" is ???
  
  """
  extra: JSON

  """Reads a single `Event` that is related to this `Challenge`."""
  eventByEvent: Event

  """
  Reads a single `ChallengeCategory` that is related to this `Challenge`.
  """
  challengeCategoryByCategory: ChallengeCategory

  """Reads a single `Currency` that is related to this `Challenge`."""
  currencyByRewardsCurrency: Currency

  """Reads a single `VoteOption` that is related to this `Challenge`."""
  voteOptionByVoteOptions: VoteOption

  """Reads and enables pagination through a set of `Proposal`."""
  proposalsByChallenge(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Proposal`."""
    orderBy: [ProposalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProposalCondition
  ): ProposalsConnection!

  """Reads and enables pagination through a set of `Vote`."""
  votesByChallenge(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection!
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""The basic parameters of each voting/decision event."""
type Event implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic Unique ID for each event."""
  rowId: Int!

  """
  The name of the event.
  eg. "Fund9" or "SVE1"
  """
  name: String!

  """
  A detailed description of the purpose of the event.
  eg. the events "Goal".
  """
  description: String!

  """
  The Time (UTC) Registrations are taken from Cardano main net.
  Registrations after this date are not valid for voting on the event.
  NULL = Not yet defined or Not Applicable.
  """
  registrationSnapshotTime: Datetime

  """
  The Time (UTC) Registrations taken from Cardano main net are considered stable.
  This is not the Time of the Registration Snapshot,
  This is the time after which the registration snapshot will be stable.
  NULL = Not yet defined or Not Applicable.
  """
  snapshotStart: Datetime

  """
  The Minimum number of Lovelace staked at the time of snapshot, to be eligible to vote.
  NULL = Not yet defined.
  """
  votingPowerThreshold: BigInt
  maxVotingPowerPct: BigFloat

  """
  The time (UTC) the event starts.
  NULL = Not yet defined.
  """
  startTime: Datetime

  """
  The time (UTC) the event ends.
  NULL = Not yet defined.
  """
  endTime: Datetime

  """
  TODO.
  NULL = Not yet defined.
  """
  insightSharingStart: Datetime

  """
  The Time (UTC) proposals can start to be submitted for the event.
  NULL = Not yet defined, or Not applicable.
  """
  proposalSubmissionStart: Datetime

  """
  TODO.
  NULL = Not yet defined.
  """
  refineProposalsStart: Datetime

  """
  The Time (UTC) when all proposals must be finalized by.
  NULL = Not yet defined, or Not applicable.
  """
  finalizeProposalsStart: Datetime

  """
  The Time (UTC) when PA Assessors can start assessing proposals.
  NULL = Not yet defined, or Not applicable.
  """
  proposalAssessmentStart: Datetime

  """
  The Time (UTC) when vPA Assessors can start assessing assessments.
  NULL = Not yet defined, or Not applicable.
  """
  assessmentQaStart: Datetime

  """
  The earliest time that registered wallets with sufficient voting power can place votes in the event.
  NULL = Not yet defined.
  """
  votingStart: Datetime

  """
  The latest time that registered wallets with sufficient voting power can place votes in the event.
  NULL = Not yet defined.
  """
  votingEnd: Datetime

  """
  The latest time that tallying the event can complete by.
  NULL = Not yet defined.
  """
  tallyingEnd: Datetime

  """
  The copy of Block 0 used to start the Blockchain.
  NULL = Blockchain not started yet.
  """
  block0: String

  """
  The hash of block 0.
  NULL = Blockchain not started yet.
  """
  block0Hash: String

  """
  The size of the tally committee.
  0 = No Committee, and all votes are therefore public.
  """
  committeeSize: Int!

  """
  The minimum size of the tally committee to perform the tally.
  Must be <= `comittee_size`
  """
  committeeThreshold: Int!

  """
  Json Map defining event specific extra data.
  NULL = Not yet defined.
  "url"."results" = a results URL,
  "url"."survey" = a survey URL,
  others can be defined as required.
  """
  extra: JSON

  """Reads and enables pagination through a set of `Goal`."""
  goals(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Goal`."""
    orderBy: [GoalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GoalCondition
  ): GoalsConnection!

  """Reads and enables pagination through a set of `Challenge`."""
  challengesByEvent(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Challenge`."""
    orderBy: [ChallengesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChallengeCondition
  ): ChallengesConnection!

  """Reads and enables pagination through a set of `VotingGroup`."""
  votingGroups(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `VotingGroup`."""
    orderBy: [VotingGroupsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VotingGroupCondition
  ): VotingGroupsConnection!

  """Reads and enables pagination through a set of `Voteplan`."""
  voteplans(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Voteplan`."""
    orderBy: [VoteplansOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteplanCondition
  ): VoteplansConnection!

  """Reads a single `Snapshot` that is related to this `Event`."""
  snapshotByEvent: Snapshot

  """Reads and enables pagination through a set of `Vote`."""
  votesByEvent(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection!

  """Reads and enables pagination through a set of `VotingNode`."""
  votingNodesByEvent(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `VotingNode`."""
    orderBy: [VotingNodesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VotingNodeCondition
  ): VotingNodesConnection!

  """Reads a single `TallyCommittee` that is related to this `Event`."""
  tallyCommitteeByEvent: TallyCommittee
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""A connection to a list of `Goal` values."""
type GoalsConnection {
  """A list of `Goal` objects."""
  nodes: [Goal!]!

  """
  A list of edges which contains the `Goal` and cursor to aid in pagination.
  """
  edges: [GoalsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Goal` you could get from the connection."""
  totalCount: Int!
}

"""The list of campaign goals for this event."""
type Goal implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic Unique Key."""
  id: Int!

  """The ID of the event this goal belongs to."""
  eventId: Int!

  """The index specifying the order/priority of the goals."""
  idx: Int!

  """The description of this event goal."""
  name: String!

  """Reads a single `Event` that is related to this `Goal`."""
  event: Event
}

"""A `Goal` edge in the connection."""
type GoalsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Goal` at the end of the edge."""
  node: Goal!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `Goal`."""
enum GoalsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  EVENT_ID_ASC
  EVENT_ID_DESC
  IDX_ASC
  IDX_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Goal` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input GoalCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `eventId` field."""
  eventId: Int

  """Checks for equality with the object’s `idx` field."""
  idx: Int

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""Methods to use when ordering `Challenge`."""
enum ChallengesOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  ID_ASC
  ID_DESC
  EVENT_ASC
  EVENT_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  REWARDS_CURRENCY_ASC
  REWARDS_CURRENCY_DESC
  REWARDS_TOTAL_ASC
  REWARDS_TOTAL_DESC
  PROPOSERS_REWARDS_ASC
  PROPOSERS_REWARDS_DESC
  VOTE_OPTIONS_ASC
  VOTE_OPTIONS_DESC
  EXTRA_ASC
  EXTRA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Challenge` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ChallengeCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `event` field."""
  event: Int

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `rewardsCurrency` field."""
  rewardsCurrency: String

  """Checks for equality with the object’s `rewardsTotal` field."""
  rewardsTotal: BigInt

  """Checks for equality with the object’s `proposersRewards` field."""
  proposersRewards: BigInt

  """Checks for equality with the object’s `voteOptions` field."""
  voteOptions: Int

  """Checks for equality with the object’s `extra` field."""
  extra: JSON
}

"""A connection to a list of `VotingGroup` values."""
type VotingGroupsConnection {
  """A list of `VotingGroup` objects."""
  nodes: [VotingGroup!]!

  """
  A list of edges which contains the `VotingGroup` and cursor to aid in pagination.
  """
  edges: [VotingGroupsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `VotingGroup` you could get from the connection."""
  totalCount: Int!
}

"""All Groups."""
type VotingGroup implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic Unique Key."""
  rowId: Int!

  """The ID of this voting group."""
  groupId: String!

  """The event this voting group belongs to."""
  eventId: Int!

  """The ID of the voting token used by this group."""
  tokenId: String

  """Reads a single `Event` that is related to this `VotingGroup`."""
  event: Event

  """Reads and enables pagination through a set of `Voteplan`."""
  voteplansByGroupId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Voteplan`."""
    orderBy: [VoteplansOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteplanCondition
  ): VoteplansConnection!
}

"""A connection to a list of `Voteplan` values."""
type VoteplansConnection {
  """A list of `Voteplan` objects."""
  nodes: [Voteplan!]!

  """
  A list of edges which contains the `Voteplan` and cursor to aid in pagination.
  """
  edges: [VoteplansEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Voteplan` you could get from the connection."""
  totalCount: Int!
}

"""All Vote plans."""
type Voteplan implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic Unique Key"""
  rowId: Int!
  eventId: Int!

  """
  The ID of the Vote plan in the voting ledger/bulletin board.
  A Binary value encoded as hex.
  """
  id: String!

  """The kind of vote which can be cast on this vote plan."""
  category: String!

  """
  The public encryption key used.
  ONLY if required by the voteplan category.
  """
  encryptionKey: String

  """The identifier of voting power token used withing this plan."""
  groupId: Int

  """Reads a single `Event` that is related to this `Voteplan`."""
  event: Event

  """Reads a single `VoteplanCategory` that is related to this `Voteplan`."""
  voteplanCategoryByCategory: VoteplanCategory

  """Reads a single `VotingGroup` that is related to this `Voteplan`."""
  group: VotingGroup

  """Reads and enables pagination through a set of `ProposalVoteplan`."""
  proposalVoteplans(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProposalVoteplan`."""
    orderBy: [ProposalVoteplansOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProposalVoteplanCondition
  ): ProposalVoteplansConnection!

  """Reads and enables pagination through a set of `Vote`."""
  votesByVoteplan(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection!
}

"""The category of vote plan currently supported."""
type VoteplanCategory implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """The UNIQUE name of this voteplan category."""
  name: String!

  """Does this vote plan category require a public key."""
  publicKey: Boolean

  """Reads and enables pagination through a set of `Voteplan`."""
  voteplansByCategory(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Voteplan`."""
    orderBy: [VoteplansOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteplanCondition
  ): VoteplansConnection!
}

"""Methods to use when ordering `Voteplan`."""
enum VoteplansOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  EVENT_ID_ASC
  EVENT_ID_DESC
  ID_ASC
  ID_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  ENCRYPTION_KEY_ASC
  ENCRYPTION_KEY_DESC
  GROUP_ID_ASC
  GROUP_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Voteplan` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input VoteplanCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `eventId` field."""
  eventId: Int

  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `encryptionKey` field."""
  encryptionKey: String

  """Checks for equality with the object’s `groupId` field."""
  groupId: Int
}

"""A connection to a list of `ProposalVoteplan` values."""
type ProposalVoteplansConnection {
  """A list of `ProposalVoteplan` objects."""
  nodes: [ProposalVoteplan!]!

  """
  A list of edges which contains the `ProposalVoteplan` and cursor to aid in pagination.
  """
  edges: [ProposalVoteplansEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ProposalVoteplan` you could get from the connection.
  """
  totalCount: Int!
}

"""Table to link Proposals to Vote plans in a Many to Many relationship."""
type ProposalVoteplan implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic ID of this Voteplan/Proposal M-M relationship."""
  rowId: Int!

  """The link to the Proposal primary key that links to this voteplan."""
  proposalId: Int

  """The link to the Voteplan primary key that links to this proposal."""
  voteplanId: Int

  """
  The Index with the voteplan used by the voting ledger/bulletin board that references this proposal.
  """
  bbProposalIndex: BigInt

  """Reads a single `Proposal` that is related to this `ProposalVoteplan`."""
  proposal: Proposal

  """Reads a single `Voteplan` that is related to this `ProposalVoteplan`."""
  voteplan: Voteplan
}

"""All Proposals for the current fund."""
type Proposal implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic Unique Key"""
  rowId: Int!

  """Actual Proposal Unique ID"""
  id: Int!

  """The Challenge this proposal falls under."""
  challenge: Int!

  """Brief title of the proposal."""
  title: String!

  """A Summary of the proposal to be implemented."""
  summary: String!
  category: String!

  """???"""
  publicKey: String!

  """How much funds (in the currency of the fund)"""
  funds: BigInt!

  """A URL with supporting information for the proposal."""
  url: String!

  """A URL link to relevant files supporting the proposal."""
  filesUrl: String!

  """The Impact score assigned to this proposal by the Assessors."""
  impactScore: BigInt!

  """
  Extra data about the proposal.
   The types of extra data are defined by the proposal type and are not enforced.
   Extra Fields for `native` challenges:
      NONE.
  
   Extra Fields for `simple` challenges:
      "solution" : <text> - The Solution to the challenge.
  
   Extra Fields for `community choice` challenge:
      "brief"      : <text> - Brief explanation of a proposal.
      "importance" : <text> - The importance of the proposal.
      "goal"       : <text> - The goal of the proposal is addressed to meet.
      "metrics"    : <text> - The metrics of the proposal or how success will be determined.
  """
  extra: JSON

  """The proposers name."""
  proposerName: String!

  """Contact details for the proposer."""
  proposerContact: String!

  """A URL with details of the proposer."""
  proposerUrl: String!

  """
  A freeform  string describing the proposers experience relating to their capability to implement the proposal.
  """
  proposerRelevantExperience: String!

  """
  The ID used by the voting ledger (bulletin board) to refer to this proposal.
  """
  bbProposalId: String

  """The selectable options by the voter."""
  bbVoteOptions: String

  """Reads a single `Challenge` that is related to this `Proposal`."""
  challengeByChallenge: Challenge

  """Reads a single `VoteOption` that is related to this `Proposal`."""
  voteOptionByBbVoteOptions: VoteOption

  """
  Reads and enables pagination through a set of `CommunityAdvisorsReview`.
  """
  communityAdvisorsReviews(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CommunityAdvisorsReview`."""
    orderBy: [CommunityAdvisorsReviewsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommunityAdvisorsReviewCondition
  ): CommunityAdvisorsReviewsConnection!

  """Reads and enables pagination through a set of `ProposalVoteplan`."""
  proposalVoteplans(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProposalVoteplan`."""
    orderBy: [ProposalVoteplansOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProposalVoteplanCondition
  ): ProposalVoteplansConnection!

  """Reads and enables pagination through a set of `Vote`."""
  votesByChallengeAndProposal(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection!

  """Reads and enables pagination through a set of `Vote`."""
  votesByProposal(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection!
}

"""Defines all known vote plan option types."""
type VoteOption implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Unique ID for each possible option set."""
  id: Int!

  """How this vote option is represented in idea scale."""
  ideaScale: String

  """How the vote options is represented in the challenge."""
  challenge: String

  """Reads and enables pagination through a set of `Challenge`."""
  challengesByVoteOptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Challenge`."""
    orderBy: [ChallengesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChallengeCondition
  ): ChallengesConnection!

  """Reads and enables pagination through a set of `Proposal`."""
  proposalsByBbVoteOptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Proposal`."""
    orderBy: [ProposalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProposalCondition
  ): ProposalsConnection!
}

"""A connection to a list of `Proposal` values."""
type ProposalsConnection {
  """A list of `Proposal` objects."""
  nodes: [Proposal!]!

  """
  A list of edges which contains the `Proposal` and cursor to aid in pagination.
  """
  edges: [ProposalsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Proposal` you could get from the connection."""
  totalCount: Int!
}

"""A `Proposal` edge in the connection."""
type ProposalsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Proposal` at the end of the edge."""
  node: Proposal!
}

"""Methods to use when ordering `Proposal`."""
enum ProposalsOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  ID_ASC
  ID_DESC
  CHALLENGE_ASC
  CHALLENGE_DESC
  TITLE_ASC
  TITLE_DESC
  SUMMARY_ASC
  SUMMARY_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  PUBLIC_KEY_ASC
  PUBLIC_KEY_DESC
  FUNDS_ASC
  FUNDS_DESC
  URL_ASC
  URL_DESC
  FILES_URL_ASC
  FILES_URL_DESC
  IMPACT_SCORE_ASC
  IMPACT_SCORE_DESC
  EXTRA_ASC
  EXTRA_DESC
  PROPOSER_NAME_ASC
  PROPOSER_NAME_DESC
  PROPOSER_CONTACT_ASC
  PROPOSER_CONTACT_DESC
  PROPOSER_URL_ASC
  PROPOSER_URL_DESC
  PROPOSER_RELEVANT_EXPERIENCE_ASC
  PROPOSER_RELEVANT_EXPERIENCE_DESC
  BB_PROPOSAL_ID_ASC
  BB_PROPOSAL_ID_DESC
  BB_VOTE_OPTIONS_ASC
  BB_VOTE_OPTIONS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Proposal` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ProposalCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `challenge` field."""
  challenge: Int

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `summary` field."""
  summary: String

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `publicKey` field."""
  publicKey: String

  """Checks for equality with the object’s `funds` field."""
  funds: BigInt

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `filesUrl` field."""
  filesUrl: String

  """Checks for equality with the object’s `impactScore` field."""
  impactScore: BigInt

  """Checks for equality with the object’s `extra` field."""
  extra: JSON

  """Checks for equality with the object’s `proposerName` field."""
  proposerName: String

  """Checks for equality with the object’s `proposerContact` field."""
  proposerContact: String

  """Checks for equality with the object’s `proposerUrl` field."""
  proposerUrl: String

  """
  Checks for equality with the object’s `proposerRelevantExperience` field.
  """
  proposerRelevantExperience: String

  """Checks for equality with the object’s `bbProposalId` field."""
  bbProposalId: String

  """Checks for equality with the object’s `bbVoteOptions` field."""
  bbVoteOptions: String
}

"""A connection to a list of `CommunityAdvisorsReview` values."""
type CommunityAdvisorsReviewsConnection {
  """A list of `CommunityAdvisorsReview` objects."""
  nodes: [CommunityAdvisorsReview!]!

  """
  A list of edges which contains the `CommunityAdvisorsReview` and cursor to aid in pagination.
  """
  edges: [CommunityAdvisorsReviewsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `CommunityAdvisorsReview` you could get from the connection.
  """
  totalCount: Int!
}

"""All Reviews."""
type CommunityAdvisorsReview implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic Unique Key."""
  rowId: Int!

  """The Proposal this review is for."""
  proposalId: Int!

  """Assessors Anonymized ID"""
  assessor: String!

  """The  numeric rating assigned to the proposal by the assessor."""
  impactAlignmentRatingGiven: Int

  """A note about why the impact rating was given."""
  impactAlignmentNote: String

  """The numeric feasibility rating given."""
  feasibilityRatingGiven: Int

  """A note about why the feasibility rating was given."""
  feasibilityNote: String

  """The numeric auditability rating given."""
  auditabilityRatingGiven: Int

  """A note about the auditability rating given."""
  auditabilityNote: String

  """
  Numeric  Measure of quality of this review according to veteran community advisors.
  """
  ranking: Int

  """
  Reads a single `Proposal` that is related to this `CommunityAdvisorsReview`.
  """
  proposal: Proposal
}

"""A `CommunityAdvisorsReview` edge in the connection."""
type CommunityAdvisorsReviewsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CommunityAdvisorsReview` at the end of the edge."""
  node: CommunityAdvisorsReview!
}

"""Methods to use when ordering `CommunityAdvisorsReview`."""
enum CommunityAdvisorsReviewsOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  PROPOSAL_ID_ASC
  PROPOSAL_ID_DESC
  ASSESSOR_ASC
  ASSESSOR_DESC
  IMPACT_ALIGNMENT_RATING_GIVEN_ASC
  IMPACT_ALIGNMENT_RATING_GIVEN_DESC
  IMPACT_ALIGNMENT_NOTE_ASC
  IMPACT_ALIGNMENT_NOTE_DESC
  FEASIBILITY_RATING_GIVEN_ASC
  FEASIBILITY_RATING_GIVEN_DESC
  FEASIBILITY_NOTE_ASC
  FEASIBILITY_NOTE_DESC
  AUDITABILITY_RATING_GIVEN_ASC
  AUDITABILITY_RATING_GIVEN_DESC
  AUDITABILITY_NOTE_ASC
  AUDITABILITY_NOTE_DESC
  RANKING_ASC
  RANKING_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CommunityAdvisorsReview` object types. All
fields are tested for equality and combined with a logical ‘and.’
"""
input CommunityAdvisorsReviewCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `proposalId` field."""
  proposalId: Int

  """Checks for equality with the object’s `assessor` field."""
  assessor: String

  """
  Checks for equality with the object’s `impactAlignmentRatingGiven` field.
  """
  impactAlignmentRatingGiven: Int

  """Checks for equality with the object’s `impactAlignmentNote` field."""
  impactAlignmentNote: String

  """Checks for equality with the object’s `feasibilityRatingGiven` field."""
  feasibilityRatingGiven: Int

  """Checks for equality with the object’s `feasibilityNote` field."""
  feasibilityNote: String

  """Checks for equality with the object’s `auditabilityRatingGiven` field."""
  auditabilityRatingGiven: Int

  """Checks for equality with the object’s `auditabilityNote` field."""
  auditabilityNote: String

  """Checks for equality with the object’s `ranking` field."""
  ranking: Int
}

"""Methods to use when ordering `ProposalVoteplan`."""
enum ProposalVoteplansOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  PROPOSAL_ID_ASC
  PROPOSAL_ID_DESC
  VOTEPLAN_ID_ASC
  VOTEPLAN_ID_DESC
  BB_PROPOSAL_INDEX_ASC
  BB_PROPOSAL_INDEX_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ProposalVoteplan` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ProposalVoteplanCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `proposalId` field."""
  proposalId: Int

  """Checks for equality with the object’s `voteplanId` field."""
  voteplanId: Int

  """Checks for equality with the object’s `bbProposalIndex` field."""
  bbProposalIndex: BigInt
}

"""A connection to a list of `Vote` values."""
type VotesConnection {
  """A list of `Vote` objects."""
  nodes: [Vote!]!

  """
  A list of edges which contains the `Vote` and cursor to aid in pagination.
  """
  edges: [VotesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Vote` you could get from the connection."""
  totalCount: Int!
}

"""All Votes."""
type Vote implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  rowId: BigInt!
  event: Int

  """Unique ID of this Vote"""
  fragmentId: String

  """Reference to the Voter who cast the vote"""
  voter: Int!

  """Reference to the Challenge the vote was for."""
  challenge: Int!

  """
  Reference to the Proposal the vote was for.
  May be NULL if this vote covers ALL proposals in the challenge.
  """
  proposal: Int

  """The Voteplan this vote was cast in"""
  voteplan: Int!

  """When this vote was recorded as properly cast"""
  castAt: Datetime!

  """If a public vote, the choice of the vote, otherwise NULL."""
  choice: Int

  """The raw vote record."""
  rawFragment: String!

  """Reads a single `Event` that is related to this `Vote`."""
  eventByEvent: Event

  """Reads a single `Voter` that is related to this `Vote`."""
  voterByVoter: Voter

  """Reads a single `Challenge` that is related to this `Vote`."""
  challengeByChallenge: Challenge

  """Reads a single `Proposal` that is related to this `Vote`."""
  proposalByChallengeAndProposal: Proposal

  """Reads a single `Proposal` that is related to this `Vote`."""
  proposalByProposal: Proposal

  """Reads a single `Voteplan` that is related to this `Vote`."""
  voteplanByVoteplan: Voteplan
}

"""Voting Power for every voting key."""
type Voter implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  rowId: BigInt!

  """Either the voting key."""
  votingKey: String!

  """The ID of the snapshot this record belongs to."""
  snapshotId: Int!

  """The voter group the voter belongs to."""
  votingGroup: String!

  """Calculated Voting Power associated with this key."""
  votingPower: BigInt!

  """Reads a single `Snapshot` that is related to this `Voter`."""
  snapshot: Snapshot

  """Reads and enables pagination through a set of `Vote`."""
  votesByVoter(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoteCondition
  ): VotesConnection!
}

"""
Raw snapshot data for an event.
Only the latests snapshot per event is stored.
"""
type Snapshot implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  rowId: Int!

  """The event id this snapshot was for."""
  event: Int!

  """
  The time the snapshot was collected from dbsync
  (Should be the slot time the dbsync_snapshot_cmd was run against.)
  """
  asAt: Datetime!

  """
  The last time the snapshot was run
  (Should be the real time the snapshot was started.
  """
  lastUpdated: Datetime!

  """
  Is the snapshot Final?
  No more updates will occur to this record once set.
  """
  final: Boolean!

  """The name of the command run to collect the snapshot from dbsync."""
  dbsyncSnapshotCmd: String

  """
  The parameters passed to the command, each parameter is a key and its value is the value of the parameter.
  """
  dbsyncSnapshotParams: JSON

  """
  The raw json result stored as TEXT from the dbsync snapshot.
  (This is JSON data but we store as raw text to prevent any processing of it).
  """
  dbsyncSnapshotData: String

  """
  The latest drep data obtained from GVC, and used in this snapshot calculation.
  Should be in a form directly usable by the `catalyst_snapshot_cmd`
  """
  drepData: String

  """
  The actual name of the command run to produce the catalyst voting power snapshot.
  """
  catalystSnapshotCmd: String
  catalystSnapshotParams: JSON

  """
  The raw yaml result stored as TEXT from the catalyst snapshot calculation.
  (This is YAML data but we store as raw text to prevent any processing of it).
  """
  catalystSnapshotData: String

  """Reads a single `Event` that is related to this `Snapshot`."""
  eventByEvent: Event

  """Reads and enables pagination through a set of `Voter`."""
  voters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Voter`."""
    orderBy: [VotersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VoterCondition
  ): VotersConnection!

  """Reads and enables pagination through a set of `Contribution`."""
  contributions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Contribution`."""
    orderBy: [ContributionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContributionCondition
  ): ContributionsConnection!
}

"""A connection to a list of `Voter` values."""
type VotersConnection {
  """A list of `Voter` objects."""
  nodes: [Voter!]!

  """
  A list of edges which contains the `Voter` and cursor to aid in pagination.
  """
  edges: [VotersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Voter` you could get from the connection."""
  totalCount: Int!
}

"""A `Voter` edge in the connection."""
type VotersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Voter` at the end of the edge."""
  node: Voter!
}

"""Methods to use when ordering `Voter`."""
enum VotersOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  VOTING_KEY_ASC
  VOTING_KEY_DESC
  SNAPSHOT_ID_ASC
  SNAPSHOT_ID_DESC
  VOTING_GROUP_ASC
  VOTING_GROUP_DESC
  VOTING_POWER_ASC
  VOTING_POWER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Voter` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input VoterCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: BigInt

  """Checks for equality with the object’s `votingKey` field."""
  votingKey: String

  """Checks for equality with the object’s `snapshotId` field."""
  snapshotId: Int

  """Checks for equality with the object’s `votingGroup` field."""
  votingGroup: String

  """Checks for equality with the object’s `votingPower` field."""
  votingPower: BigInt
}

"""A connection to a list of `Contribution` values."""
type ContributionsConnection {
  """A list of `Contribution` objects."""
  nodes: [Contribution!]!

  """
  A list of edges which contains the `Contribution` and cursor to aid in pagination.
  """
  edges: [ContributionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Contribution` you could get from the connection."""
  totalCount: Int!
}

"""Individual Contributions from stake public keys to voting keys."""
type Contribution implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Synthetic Unique Row Key"""
  rowId: BigInt!

  """The voters Stake Public Key"""
  stakePublicKey: String!

  """The snapshot this contribution was recorded from."""
  snapshotId: Int!

  """The voting key.  If this is NULL it is the raw staked ADA."""
  votingKey: String

  """The weight this voting key gets of the total."""
  votingWeight: Int

  """The index from 0 of the keys in the delegation array."""
  votingKeyIdx: Int

  """
  The amount of ADA contributed to this voting key from the stake address
  """
  value: BigInt!

  """The group this contribution goes to."""
  votingGroup: String!

  """
  Currently Unused.  Should be the Stake Rewards address of the voter (currently unknown.)
  """
  rewardAddress: String

  """Reads a single `Snapshot` that is related to this `Contribution`."""
  snapshot: Snapshot
}

"""A `Contribution` edge in the connection."""
type ContributionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Contribution` at the end of the edge."""
  node: Contribution!
}

"""Methods to use when ordering `Contribution`."""
enum ContributionsOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  STAKE_PUBLIC_KEY_ASC
  STAKE_PUBLIC_KEY_DESC
  SNAPSHOT_ID_ASC
  SNAPSHOT_ID_DESC
  VOTING_KEY_ASC
  VOTING_KEY_DESC
  VOTING_WEIGHT_ASC
  VOTING_WEIGHT_DESC
  VOTING_KEY_IDX_ASC
  VOTING_KEY_IDX_DESC
  VALUE_ASC
  VALUE_DESC
  VOTING_GROUP_ASC
  VOTING_GROUP_DESC
  REWARD_ADDRESS_ASC
  REWARD_ADDRESS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Contribution` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ContributionCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: BigInt

  """Checks for equality with the object’s `stakePublicKey` field."""
  stakePublicKey: String

  """Checks for equality with the object’s `snapshotId` field."""
  snapshotId: Int

  """Checks for equality with the object’s `votingKey` field."""
  votingKey: String

  """Checks for equality with the object’s `votingWeight` field."""
  votingWeight: Int

  """Checks for equality with the object’s `votingKeyIdx` field."""
  votingKeyIdx: Int

  """Checks for equality with the object’s `value` field."""
  value: BigInt

  """Checks for equality with the object’s `votingGroup` field."""
  votingGroup: String

  """Checks for equality with the object’s `rewardAddress` field."""
  rewardAddress: String
}

"""Methods to use when ordering `Vote`."""
enum VotesOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  EVENT_ASC
  EVENT_DESC
  FRAGMENT_ID_ASC
  FRAGMENT_ID_DESC
  VOTER_ASC
  VOTER_DESC
  CHALLENGE_ASC
  CHALLENGE_DESC
  PROPOSAL_ASC
  PROPOSAL_DESC
  VOTEPLAN_ASC
  VOTEPLAN_DESC
  CAST_AT_ASC
  CAST_AT_DESC
  CHOICE_ASC
  CHOICE_DESC
  RAW_FRAGMENT_ASC
  RAW_FRAGMENT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Vote` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input VoteCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: BigInt

  """Checks for equality with the object’s `event` field."""
  event: Int

  """Checks for equality with the object’s `fragmentId` field."""
  fragmentId: String

  """Checks for equality with the object’s `voter` field."""
  voter: Int

  """Checks for equality with the object’s `challenge` field."""
  challenge: Int

  """Checks for equality with the object’s `proposal` field."""
  proposal: Int

  """Checks for equality with the object’s `voteplan` field."""
  voteplan: Int

  """Checks for equality with the object’s `castAt` field."""
  castAt: Datetime

  """Checks for equality with the object’s `choice` field."""
  choice: Int

  """Checks for equality with the object’s `rawFragment` field."""
  rawFragment: String
}

"""A `Vote` edge in the connection."""
type VotesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Vote` at the end of the edge."""
  node: Vote!
}

"""A `ProposalVoteplan` edge in the connection."""
type ProposalVoteplansEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProposalVoteplan` at the end of the edge."""
  node: ProposalVoteplan!
}

"""A `Voteplan` edge in the connection."""
type VoteplansEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Voteplan` at the end of the edge."""
  node: Voteplan!
}

"""A `VotingGroup` edge in the connection."""
type VotingGroupsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `VotingGroup` at the end of the edge."""
  node: VotingGroup!
}

"""Methods to use when ordering `VotingGroup`."""
enum VotingGroupsOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  GROUP_ID_ASC
  GROUP_ID_DESC
  EVENT_ID_ASC
  EVENT_ID_DESC
  TOKEN_ID_ASC
  TOKEN_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `VotingGroup` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input VotingGroupCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `groupId` field."""
  groupId: String

  """Checks for equality with the object’s `eventId` field."""
  eventId: Int

  """Checks for equality with the object’s `tokenId` field."""
  tokenId: String
}

"""A connection to a list of `VotingNode` values."""
type VotingNodesConnection {
  """A list of `VotingNode` objects."""
  nodes: [VotingNode!]!

  """
  A list of edges which contains the `VotingNode` and cursor to aid in pagination.
  """
  edges: [VotingNodesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `VotingNode` you could get from the connection."""
  totalCount: Int!
}

"""
This table holds information for all nodes in the event.
It is used by nodes to self-bootstrap the blockchain.
"""
type VotingNode implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Unique hostname for the voting node."""
  hostname: String!

  """Unique event this node was configured for."""
  event: Int!

  """
  Public key from Ed25519 pair for the node.
  Used as consensus_leader_id when the node is a leader.
  """
  pubkey: String!

  """Secret key from Ed25519 pair for the node. Used as the node secret."""
  seckey: String!

  """
  Ed25519 secret key for the node.
  Used as the node p2p topology key.
  """
  netkey: String!

  """Reads a single `Event` that is related to this `VotingNode`."""
  eventByEvent: Event
}

"""A `VotingNode` edge in the connection."""
type VotingNodesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `VotingNode` at the end of the edge."""
  node: VotingNode!
}

"""Methods to use when ordering `VotingNode`."""
enum VotingNodesOrderBy {
  NATURAL
  HOSTNAME_ASC
  HOSTNAME_DESC
  EVENT_ASC
  EVENT_DESC
  PUBKEY_ASC
  PUBKEY_DESC
  SECKEY_ASC
  SECKEY_DESC
  NETKEY_ASC
  NETKEY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `VotingNode` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input VotingNodeCondition {
  """Checks for equality with the object’s `hostname` field."""
  hostname: String

  """Checks for equality with the object’s `event` field."""
  event: Int

  """Checks for equality with the object’s `pubkey` field."""
  pubkey: String

  """Checks for equality with the object’s `seckey` field."""
  seckey: String

  """Checks for equality with the object’s `netkey` field."""
  netkey: String
}

"""Table for storing data about the tally committee per voting event."""
type TallyCommittee implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Unique ID for this committee member for this event."""
  rowId: Int!

  """The event this committee member is for."""
  event: Int!

  """Reads a single `Event` that is related to this `TallyCommittee`."""
  eventByEvent: Event
}

"""Defines all known and valid challenge categories."""
type ChallengeCategory implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """The name of this challenge category."""
  name: String!

  """A Description of this kind of challenge category."""
  description: String

  """Reads and enables pagination through a set of `Challenge`."""
  challengesByCategory(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Challenge`."""
    orderBy: [ChallengesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChallengeCondition
  ): ChallengesConnection!
}

"""Defines all known and valid currencies."""
type Currency implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """The name of this currency type."""
  name: String!

  """A Description of this kind of currency type."""
  description: String

  """Reads and enables pagination through a set of `Challenge`."""
  challengesByRewardsCurrency(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Challenge`."""
    orderBy: [ChallengesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChallengeCondition
  ): ChallengesConnection!
}

"""A `Challenge` edge in the connection."""
type ChallengesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Challenge` at the end of the edge."""
  node: Challenge!
}

"""A connection to a list of `ChallengeCategory` values."""
type ChallengeCategoriesConnection {
  """A list of `ChallengeCategory` objects."""
  nodes: [ChallengeCategory!]!

  """
  A list of edges which contains the `ChallengeCategory` and cursor to aid in pagination.
  """
  edges: [ChallengeCategoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ChallengeCategory` you could get from the connection.
  """
  totalCount: Int!
}

"""A `ChallengeCategory` edge in the connection."""
type ChallengeCategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ChallengeCategory` at the end of the edge."""
  node: ChallengeCategory!
}

"""Methods to use when ordering `ChallengeCategory`."""
enum ChallengeCategoriesOrderBy {
  NATURAL
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ChallengeCategory` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ChallengeCategoryCondition {
  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String
}

"""A connection to a list of `Config` values."""
type ConfigsConnection {
  """A list of `Config` objects."""
  nodes: [Config!]!

  """
  A list of edges which contains the `Config` and cursor to aid in pagination.
  """
  edges: [ConfigsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Config` you could get from the connection."""
  totalCount: Int!
}

"""
General JSON Configuration and Data Values.
Defined  Data Formats:
  API Tokens:
    `id` = "api_token"
    `id2` = <API Token, encrypted with a secret, as base-64 encoded string "">`
    `id3` = "" (Unused),
    `value`->"name" = "<Name of the token owner>",
    `value`->"created" = <Integer Unix Epoch when Token was created>,
    `value`->"expires" = <Integer Unix Epoch when Token will expire>,
    `value`->"perms" = {Permissions assigned to this api key}

"""
type Config implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Synthetic unique key.
  Always lookup using id.
  """
  rowId: Int!

  """The name/id of the general config value/variable"""
  id: String!

  """
  2nd ID of the general config value.
  Must be defined, use "" if not required.
  """
  id2: String!

  """
  3rd ID of the general config value.
  Must be defined, use "" if not required.
  """
  id3: String!

  """The JSON value of the system variable id.id2.id3"""
  value: JSON
}

"""A `Config` edge in the connection."""
type ConfigsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Config` at the end of the edge."""
  node: Config!
}

"""Methods to use when ordering `Config`."""
enum ConfigsOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  ID_ASC
  ID_DESC
  ID2_ASC
  ID2_DESC
  ID3_ASC
  ID3_DESC
  VALUE_ASC
  VALUE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Config` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ConfigCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `id2` field."""
  id2: String

  """Checks for equality with the object’s `id3` field."""
  id3: String

  """Checks for equality with the object’s `value` field."""
  value: JSON
}

"""A connection to a list of `Currency` values."""
type CurrenciesConnection {
  """A list of `Currency` objects."""
  nodes: [Currency!]!

  """
  A list of edges which contains the `Currency` and cursor to aid in pagination.
  """
  edges: [CurrenciesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Currency` you could get from the connection."""
  totalCount: Int!
}

"""A `Currency` edge in the connection."""
type CurrenciesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Currency` at the end of the edge."""
  node: Currency!
}

"""Methods to use when ordering `Currency`."""
enum CurrenciesOrderBy {
  NATURAL
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Currency` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CurrencyCondition {
  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String
}

"""A connection to a list of `Event` values."""
type EventsConnection {
  """A list of `Event` objects."""
  nodes: [Event!]!

  """
  A list of edges which contains the `Event` and cursor to aid in pagination.
  """
  edges: [EventsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Event` you could get from the connection."""
  totalCount: Int!
}

"""A `Event` edge in the connection."""
type EventsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Event` at the end of the edge."""
  node: Event!
}

"""Methods to use when ordering `Event`."""
enum EventsOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  REGISTRATION_SNAPSHOT_TIME_ASC
  REGISTRATION_SNAPSHOT_TIME_DESC
  SNAPSHOT_START_ASC
  SNAPSHOT_START_DESC
  VOTING_POWER_THRESHOLD_ASC
  VOTING_POWER_THRESHOLD_DESC
  MAX_VOTING_POWER_PCT_ASC
  MAX_VOTING_POWER_PCT_DESC
  START_TIME_ASC
  START_TIME_DESC
  END_TIME_ASC
  END_TIME_DESC
  INSIGHT_SHARING_START_ASC
  INSIGHT_SHARING_START_DESC
  PROPOSAL_SUBMISSION_START_ASC
  PROPOSAL_SUBMISSION_START_DESC
  REFINE_PROPOSALS_START_ASC
  REFINE_PROPOSALS_START_DESC
  FINALIZE_PROPOSALS_START_ASC
  FINALIZE_PROPOSALS_START_DESC
  PROPOSAL_ASSESSMENT_START_ASC
  PROPOSAL_ASSESSMENT_START_DESC
  ASSESSMENT_QA_START_ASC
  ASSESSMENT_QA_START_DESC
  VOTING_START_ASC
  VOTING_START_DESC
  VOTING_END_ASC
  VOTING_END_DESC
  TALLYING_END_ASC
  TALLYING_END_DESC
  BLOCK0_ASC
  BLOCK0_DESC
  BLOCK0_HASH_ASC
  BLOCK0_HASH_DESC
  COMMITTEE_SIZE_ASC
  COMMITTEE_SIZE_DESC
  COMMITTEE_THRESHOLD_ASC
  COMMITTEE_THRESHOLD_DESC
  EXTRA_ASC
  EXTRA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input EventCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """
  Checks for equality with the object’s `registrationSnapshotTime` field.
  """
  registrationSnapshotTime: Datetime

  """Checks for equality with the object’s `snapshotStart` field."""
  snapshotStart: Datetime

  """Checks for equality with the object’s `votingPowerThreshold` field."""
  votingPowerThreshold: BigInt

  """Checks for equality with the object’s `maxVotingPowerPct` field."""
  maxVotingPowerPct: BigFloat

  """Checks for equality with the object’s `startTime` field."""
  startTime: Datetime

  """Checks for equality with the object’s `endTime` field."""
  endTime: Datetime

  """Checks for equality with the object’s `insightSharingStart` field."""
  insightSharingStart: Datetime

  """Checks for equality with the object’s `proposalSubmissionStart` field."""
  proposalSubmissionStart: Datetime

  """Checks for equality with the object’s `refineProposalsStart` field."""
  refineProposalsStart: Datetime

  """Checks for equality with the object’s `finalizeProposalsStart` field."""
  finalizeProposalsStart: Datetime

  """Checks for equality with the object’s `proposalAssessmentStart` field."""
  proposalAssessmentStart: Datetime

  """Checks for equality with the object’s `assessmentQaStart` field."""
  assessmentQaStart: Datetime

  """Checks for equality with the object’s `votingStart` field."""
  votingStart: Datetime

  """Checks for equality with the object’s `votingEnd` field."""
  votingEnd: Datetime

  """Checks for equality with the object’s `tallyingEnd` field."""
  tallyingEnd: Datetime

  """Checks for equality with the object’s `block0` field."""
  block0: String

  """Checks for equality with the object’s `block0Hash` field."""
  block0Hash: String

  """Checks for equality with the object’s `committeeSize` field."""
  committeeSize: Int

  """Checks for equality with the object’s `committeeThreshold` field."""
  committeeThreshold: Int

  """Checks for equality with the object’s `extra` field."""
  extra: JSON
}

"""A connection to a list of `ProposalCommunityChoiceChallenge` values."""
type ProposalCommunityChoiceChallengesConnection {
  """A list of `ProposalCommunityChoiceChallenge` objects."""
  nodes: [ProposalCommunityChoiceChallenge!]!

  """
  A list of edges which contains the `ProposalCommunityChoiceChallenge` and cursor to aid in pagination.
  """
  edges: [ProposalCommunityChoiceChallengesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ProposalCommunityChoiceChallenge` you could get from the connection.
  """
  totalCount: Int!
}

"""
This view maps the original VIT-SS proposal_community_choice_challenge table to the new proposal table.
Do not use this VIEW for new queries, its ONLY for backward compatibility.
@name vitss_proposal_community_choice_challenge
@omit
"""
type ProposalCommunityChoiceChallenge {
  proposalId: String
  proposalSolution: String
  proposalBrief: String
  proposalImportance: String
  proposalGoal: String
  proposalMetrics: String
}

"""A `ProposalCommunityChoiceChallenge` edge in the connection."""
type ProposalCommunityChoiceChallengesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProposalCommunityChoiceChallenge` at the end of the edge."""
  node: ProposalCommunityChoiceChallenge!
}

"""Methods to use when ordering `ProposalCommunityChoiceChallenge`."""
enum ProposalCommunityChoiceChallengesOrderBy {
  NATURAL
  PROPOSAL_ID_ASC
  PROPOSAL_ID_DESC
  PROPOSAL_SOLUTION_ASC
  PROPOSAL_SOLUTION_DESC
  PROPOSAL_BRIEF_ASC
  PROPOSAL_BRIEF_DESC
  PROPOSAL_IMPORTANCE_ASC
  PROPOSAL_IMPORTANCE_DESC
  PROPOSAL_GOAL_ASC
  PROPOSAL_GOAL_DESC
  PROPOSAL_METRICS_ASC
  PROPOSAL_METRICS_DESC
}

"""
A condition to be used against `ProposalCommunityChoiceChallenge` object types.
All fields are tested for equality and combined with a logical ‘and.’
"""
input ProposalCommunityChoiceChallengeCondition {
  """Checks for equality with the object’s `proposalId` field."""
  proposalId: String

  """Checks for equality with the object’s `proposalSolution` field."""
  proposalSolution: String

  """Checks for equality with the object’s `proposalBrief` field."""
  proposalBrief: String

  """Checks for equality with the object’s `proposalImportance` field."""
  proposalImportance: String

  """Checks for equality with the object’s `proposalGoal` field."""
  proposalGoal: String

  """Checks for equality with the object’s `proposalMetrics` field."""
  proposalMetrics: String
}

"""A connection to a list of `RefinerySchemaHistory` values."""
type RefinerySchemaHistoriesConnection {
  """A list of `RefinerySchemaHistory` objects."""
  nodes: [RefinerySchemaHistory!]!

  """
  A list of edges which contains the `RefinerySchemaHistory` and cursor to aid in pagination.
  """
  edges: [RefinerySchemaHistoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `RefinerySchemaHistory` you could get from the connection.
  """
  totalCount: Int!
}

"""
History of Schema Updates to the Database.
Managed by the `refinery` cli tool.

"""
type RefinerySchemaHistory implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  version: Int!
  name: String
  appliedOn: String
  checksum: String
}

"""A `RefinerySchemaHistory` edge in the connection."""
type RefinerySchemaHistoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `RefinerySchemaHistory` at the end of the edge."""
  node: RefinerySchemaHistory!
}

"""Methods to use when ordering `RefinerySchemaHistory`."""
enum RefinerySchemaHistoriesOrderBy {
  NATURAL
  VERSION_ASC
  VERSION_DESC
  NAME_ASC
  NAME_DESC
  APPLIED_ON_ASC
  APPLIED_ON_DESC
  CHECKSUM_ASC
  CHECKSUM_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `RefinerySchemaHistory` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input RefinerySchemaHistoryCondition {
  """Checks for equality with the object’s `version` field."""
  version: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `appliedOn` field."""
  appliedOn: String

  """Checks for equality with the object’s `checksum` field."""
  checksum: String
}

"""A connection to a list of `Snapshot` values."""
type SnapshotsConnection {
  """A list of `Snapshot` objects."""
  nodes: [Snapshot!]!

  """
  A list of edges which contains the `Snapshot` and cursor to aid in pagination.
  """
  edges: [SnapshotsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Snapshot` you could get from the connection."""
  totalCount: Int!
}

"""A `Snapshot` edge in the connection."""
type SnapshotsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Snapshot` at the end of the edge."""
  node: Snapshot!
}

"""Methods to use when ordering `Snapshot`."""
enum SnapshotsOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  EVENT_ASC
  EVENT_DESC
  AS_AT_ASC
  AS_AT_DESC
  LAST_UPDATED_ASC
  LAST_UPDATED_DESC
  FINAL_ASC
  FINAL_DESC
  DBSYNC_SNAPSHOT_CMD_ASC
  DBSYNC_SNAPSHOT_CMD_DESC
  DBSYNC_SNAPSHOT_PARAMS_ASC
  DBSYNC_SNAPSHOT_PARAMS_DESC
  DBSYNC_SNAPSHOT_DATA_ASC
  DBSYNC_SNAPSHOT_DATA_DESC
  DREP_DATA_ASC
  DREP_DATA_DESC
  CATALYST_SNAPSHOT_CMD_ASC
  CATALYST_SNAPSHOT_CMD_DESC
  CATALYST_SNAPSHOT_PARAMS_ASC
  CATALYST_SNAPSHOT_PARAMS_DESC
  CATALYST_SNAPSHOT_DATA_ASC
  CATALYST_SNAPSHOT_DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Snapshot` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input SnapshotCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `event` field."""
  event: Int

  """Checks for equality with the object’s `asAt` field."""
  asAt: Datetime

  """Checks for equality with the object’s `lastUpdated` field."""
  lastUpdated: Datetime

  """Checks for equality with the object’s `final` field."""
  final: Boolean

  """Checks for equality with the object’s `dbsyncSnapshotCmd` field."""
  dbsyncSnapshotCmd: String

  """Checks for equality with the object’s `dbsyncSnapshotParams` field."""
  dbsyncSnapshotParams: JSON

  """Checks for equality with the object’s `dbsyncSnapshotData` field."""
  dbsyncSnapshotData: String

  """Checks for equality with the object’s `drepData` field."""
  drepData: String

  """Checks for equality with the object’s `catalystSnapshotCmd` field."""
  catalystSnapshotCmd: String

  """Checks for equality with the object’s `catalystSnapshotParams` field."""
  catalystSnapshotParams: JSON

  """Checks for equality with the object’s `catalystSnapshotData` field."""
  catalystSnapshotData: String
}

"""A connection to a list of `TallyCommittee` values."""
type TallyCommitteesConnection {
  """A list of `TallyCommittee` objects."""
  nodes: [TallyCommittee!]!

  """
  A list of edges which contains the `TallyCommittee` and cursor to aid in pagination.
  """
  edges: [TallyCommitteesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TallyCommittee` you could get from the connection."""
  totalCount: Int!
}

"""A `TallyCommittee` edge in the connection."""
type TallyCommitteesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TallyCommittee` at the end of the edge."""
  node: TallyCommittee!
}

"""Methods to use when ordering `TallyCommittee`."""
enum TallyCommitteesOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  EVENT_ASC
  EVENT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TallyCommittee` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TallyCommitteeCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: Int

  """Checks for equality with the object’s `event` field."""
  event: Int
}

"""A connection to a list of `VoteOption` values."""
type VoteOptionsConnection {
  """A list of `VoteOption` objects."""
  nodes: [VoteOption!]!

  """
  A list of edges which contains the `VoteOption` and cursor to aid in pagination.
  """
  edges: [VoteOptionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `VoteOption` you could get from the connection."""
  totalCount: Int!
}

"""A `VoteOption` edge in the connection."""
type VoteOptionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `VoteOption` at the end of the edge."""
  node: VoteOption!
}

"""Methods to use when ordering `VoteOption`."""
enum VoteOptionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  IDEA_SCALE_ASC
  IDEA_SCALE_DESC
  CHALLENGE_ASC
  CHALLENGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `VoteOption` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input VoteOptionCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `ideaScale` field."""
  ideaScale: String

  """Checks for equality with the object’s `challenge` field."""
  challenge: String
}

"""A connection to a list of `VoteplanCategory` values."""
type VoteplanCategoriesConnection {
  """A list of `VoteplanCategory` objects."""
  nodes: [VoteplanCategory!]!

  """
  A list of edges which contains the `VoteplanCategory` and cursor to aid in pagination.
  """
  edges: [VoteplanCategoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `VoteplanCategory` you could get from the connection.
  """
  totalCount: Int!
}

"""A `VoteplanCategory` edge in the connection."""
type VoteplanCategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `VoteplanCategory` at the end of the edge."""
  node: VoteplanCategory!
}

"""Methods to use when ordering `VoteplanCategory`."""
enum VoteplanCategoriesOrderBy {
  NATURAL
  NAME_ASC
  NAME_DESC
  PUBLIC_KEY_ASC
  PUBLIC_KEY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `VoteplanCategory` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input VoteplanCategoryCondition {
  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `publicKey` field."""
  publicKey: Boolean
}

type AdminAccount implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  firstName: String!
  lastName: String
  role: String
  about: String
  email: String!
  passwordHash: String!
  createdAt: Datetime
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Challenge`."""
  createChallenge(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateChallengeInput!
  ): CreateChallengePayload

  """Creates a single `ChallengeCategory`."""
  createChallengeCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateChallengeCategoryInput!
  ): CreateChallengeCategoryPayload

  """Creates a single `CommunityAdvisorsReview`."""
  createCommunityAdvisorsReview(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCommunityAdvisorsReviewInput!
  ): CreateCommunityAdvisorsReviewPayload

  """Creates a single `Config`."""
  createConfig(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateConfigInput!
  ): CreateConfigPayload

  """Creates a single `Contribution`."""
  createContribution(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateContributionInput!
  ): CreateContributionPayload

  """Creates a single `Currency`."""
  createCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCurrencyInput!
  ): CreateCurrencyPayload

  """Creates a single `Event`."""
  createEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateEventInput!
  ): CreateEventPayload

  """Creates a single `Goal`."""
  createGoal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGoalInput!
  ): CreateGoalPayload

  """Creates a single `Proposal`."""
  createProposal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProposalInput!
  ): CreateProposalPayload

  """Creates a single `ProposalVoteplan`."""
  createProposalVoteplan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProposalVoteplanInput!
  ): CreateProposalVoteplanPayload

  """Creates a single `RefinerySchemaHistory`."""
  createRefinerySchemaHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateRefinerySchemaHistoryInput!
  ): CreateRefinerySchemaHistoryPayload

  """Creates a single `Snapshot`."""
  createSnapshot(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSnapshotInput!
  ): CreateSnapshotPayload

  """Creates a single `TallyCommittee`."""
  createTallyCommittee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTallyCommitteeInput!
  ): CreateTallyCommitteePayload

  """Creates a single `Vote`."""
  createVote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVoteInput!
  ): CreateVotePayload

  """Creates a single `VoteOption`."""
  createVoteOption(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVoteOptionInput!
  ): CreateVoteOptionPayload

  """Creates a single `Voteplan`."""
  createVoteplan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVoteplanInput!
  ): CreateVoteplanPayload

  """Creates a single `VoteplanCategory`."""
  createVoteplanCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVoteplanCategoryInput!
  ): CreateVoteplanCategoryPayload

  """Creates a single `Voter`."""
  createVoter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVoterInput!
  ): CreateVoterPayload

  """Creates a single `VotingGroup`."""
  createVotingGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVotingGroupInput!
  ): CreateVotingGroupPayload

  """Creates a single `VotingNode`."""
  createVotingNode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVotingNodeInput!
  ): CreateVotingNodePayload

  """Updates a single `Challenge` using its globally unique id and a patch."""
  updateChallengeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateChallengeByNodeIdInput!
  ): UpdateChallengePayload

  """Updates a single `Challenge` using a unique key and a patch."""
  updateChallenge(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateChallengeInput!
  ): UpdateChallengePayload

  """
  Updates a single `ChallengeCategory` using its globally unique id and a patch.
  """
  updateChallengeCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateChallengeCategoryByNodeIdInput!
  ): UpdateChallengeCategoryPayload

  """Updates a single `ChallengeCategory` using a unique key and a patch."""
  updateChallengeCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateChallengeCategoryInput!
  ): UpdateChallengeCategoryPayload

  """
  Updates a single `CommunityAdvisorsReview` using its globally unique id and a patch.
  """
  updateCommunityAdvisorsReviewByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCommunityAdvisorsReviewByNodeIdInput!
  ): UpdateCommunityAdvisorsReviewPayload

  """
  Updates a single `CommunityAdvisorsReview` using a unique key and a patch.
  """
  updateCommunityAdvisorsReview(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCommunityAdvisorsReviewInput!
  ): UpdateCommunityAdvisorsReviewPayload

  """Updates a single `Config` using its globally unique id and a patch."""
  updateConfigByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateConfigByNodeIdInput!
  ): UpdateConfigPayload

  """Updates a single `Config` using a unique key and a patch."""
  updateConfig(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateConfigInput!
  ): UpdateConfigPayload

  """
  Updates a single `Contribution` using its globally unique id and a patch.
  """
  updateContributionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContributionByNodeIdInput!
  ): UpdateContributionPayload

  """Updates a single `Contribution` using a unique key and a patch."""
  updateContribution(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContributionInput!
  ): UpdateContributionPayload

  """Updates a single `Currency` using its globally unique id and a patch."""
  updateCurrencyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyByNodeIdInput!
  ): UpdateCurrencyPayload

  """Updates a single `Currency` using a unique key and a patch."""
  updateCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyInput!
  ): UpdateCurrencyPayload

  """Updates a single `Event` using its globally unique id and a patch."""
  updateEventByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEventByNodeIdInput!
  ): UpdateEventPayload

  """Updates a single `Event` using a unique key and a patch."""
  updateEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEventInput!
  ): UpdateEventPayload

  """Updates a single `Goal` using its globally unique id and a patch."""
  updateGoalByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGoalByNodeIdInput!
  ): UpdateGoalPayload

  """Updates a single `Goal` using a unique key and a patch."""
  updateGoal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGoalInput!
  ): UpdateGoalPayload

  """Updates a single `Proposal` using its globally unique id and a patch."""
  updateProposalByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProposalByNodeIdInput!
  ): UpdateProposalPayload

  """Updates a single `Proposal` using a unique key and a patch."""
  updateProposal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProposalInput!
  ): UpdateProposalPayload

  """Updates a single `Proposal` using a unique key and a patch."""
  updateProposalById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProposalByIdInput!
  ): UpdateProposalPayload

  """
  Updates a single `ProposalVoteplan` using its globally unique id and a patch.
  """
  updateProposalVoteplanByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProposalVoteplanByNodeIdInput!
  ): UpdateProposalVoteplanPayload

  """Updates a single `ProposalVoteplan` using a unique key and a patch."""
  updateProposalVoteplan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProposalVoteplanInput!
  ): UpdateProposalVoteplanPayload

  """
  Updates a single `RefinerySchemaHistory` using its globally unique id and a patch.
  """
  updateRefinerySchemaHistoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRefinerySchemaHistoryByNodeIdInput!
  ): UpdateRefinerySchemaHistoryPayload

  """
  Updates a single `RefinerySchemaHistory` using a unique key and a patch.
  """
  updateRefinerySchemaHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRefinerySchemaHistoryInput!
  ): UpdateRefinerySchemaHistoryPayload

  """Updates a single `Snapshot` using its globally unique id and a patch."""
  updateSnapshotByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSnapshotByNodeIdInput!
  ): UpdateSnapshotPayload

  """Updates a single `Snapshot` using a unique key and a patch."""
  updateSnapshot(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSnapshotInput!
  ): UpdateSnapshotPayload

  """Updates a single `Snapshot` using a unique key and a patch."""
  updateSnapshotByEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSnapshotByEventInput!
  ): UpdateSnapshotPayload

  """
  Updates a single `TallyCommittee` using its globally unique id and a patch.
  """
  updateTallyCommitteeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTallyCommitteeByNodeIdInput!
  ): UpdateTallyCommitteePayload

  """Updates a single `TallyCommittee` using a unique key and a patch."""
  updateTallyCommittee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTallyCommitteeInput!
  ): UpdateTallyCommitteePayload

  """Updates a single `TallyCommittee` using a unique key and a patch."""
  updateTallyCommitteeByEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTallyCommitteeByEventInput!
  ): UpdateTallyCommitteePayload

  """Updates a single `Vote` using its globally unique id and a patch."""
  updateVoteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteByNodeIdInput!
  ): UpdateVotePayload

  """Updates a single `Vote` using a unique key and a patch."""
  updateVote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteInput!
  ): UpdateVotePayload

  """
  Updates a single `VoteOption` using its globally unique id and a patch.
  """
  updateVoteOptionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteOptionByNodeIdInput!
  ): UpdateVoteOptionPayload

  """Updates a single `VoteOption` using a unique key and a patch."""
  updateVoteOption(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteOptionInput!
  ): UpdateVoteOptionPayload

  """Updates a single `VoteOption` using a unique key and a patch."""
  updateVoteOptionByIdeaScale(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteOptionByIdeaScaleInput!
  ): UpdateVoteOptionPayload

  """Updates a single `VoteOption` using a unique key and a patch."""
  updateVoteOptionByChallenge(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteOptionByChallengeInput!
  ): UpdateVoteOptionPayload

  """Updates a single `Voteplan` using its globally unique id and a patch."""
  updateVoteplanByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteplanByNodeIdInput!
  ): UpdateVoteplanPayload

  """Updates a single `Voteplan` using a unique key and a patch."""
  updateVoteplan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteplanInput!
  ): UpdateVoteplanPayload

  """Updates a single `Voteplan` using a unique key and a patch."""
  updateVoteplanById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteplanByIdInput!
  ): UpdateVoteplanPayload

  """
  Updates a single `VoteplanCategory` using its globally unique id and a patch.
  """
  updateVoteplanCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteplanCategoryByNodeIdInput!
  ): UpdateVoteplanCategoryPayload

  """Updates a single `VoteplanCategory` using a unique key and a patch."""
  updateVoteplanCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoteplanCategoryInput!
  ): UpdateVoteplanCategoryPayload

  """Updates a single `Voter` using its globally unique id and a patch."""
  updateVoterByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoterByNodeIdInput!
  ): UpdateVoterPayload

  """Updates a single `Voter` using a unique key and a patch."""
  updateVoter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVoterInput!
  ): UpdateVoterPayload

  """
  Updates a single `VotingGroup` using its globally unique id and a patch.
  """
  updateVotingGroupByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVotingGroupByNodeIdInput!
  ): UpdateVotingGroupPayload

  """Updates a single `VotingGroup` using a unique key and a patch."""
  updateVotingGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVotingGroupInput!
  ): UpdateVotingGroupPayload

  """
  Updates a single `VotingNode` using its globally unique id and a patch.
  """
  updateVotingNodeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVotingNodeByNodeIdInput!
  ): UpdateVotingNodePayload

  """Updates a single `VotingNode` using a unique key and a patch."""
  updateVotingNode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVotingNodeInput!
  ): UpdateVotingNodePayload

  """Deletes a single `Challenge` using its globally unique id."""
  deleteChallengeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteChallengeByNodeIdInput!
  ): DeleteChallengePayload

  """Deletes a single `Challenge` using a unique key."""
  deleteChallenge(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteChallengeInput!
  ): DeleteChallengePayload

  """Deletes a single `ChallengeCategory` using its globally unique id."""
  deleteChallengeCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteChallengeCategoryByNodeIdInput!
  ): DeleteChallengeCategoryPayload

  """Deletes a single `ChallengeCategory` using a unique key."""
  deleteChallengeCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteChallengeCategoryInput!
  ): DeleteChallengeCategoryPayload

  """
  Deletes a single `CommunityAdvisorsReview` using its globally unique id.
  """
  deleteCommunityAdvisorsReviewByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCommunityAdvisorsReviewByNodeIdInput!
  ): DeleteCommunityAdvisorsReviewPayload

  """Deletes a single `CommunityAdvisorsReview` using a unique key."""
  deleteCommunityAdvisorsReview(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCommunityAdvisorsReviewInput!
  ): DeleteCommunityAdvisorsReviewPayload

  """Deletes a single `Config` using its globally unique id."""
  deleteConfigByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteConfigByNodeIdInput!
  ): DeleteConfigPayload

  """Deletes a single `Config` using a unique key."""
  deleteConfig(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteConfigInput!
  ): DeleteConfigPayload

  """Deletes a single `Contribution` using its globally unique id."""
  deleteContributionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContributionByNodeIdInput!
  ): DeleteContributionPayload

  """Deletes a single `Contribution` using a unique key."""
  deleteContribution(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContributionInput!
  ): DeleteContributionPayload

  """Deletes a single `Currency` using its globally unique id."""
  deleteCurrencyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyByNodeIdInput!
  ): DeleteCurrencyPayload

  """Deletes a single `Currency` using a unique key."""
  deleteCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyInput!
  ): DeleteCurrencyPayload

  """Deletes a single `Event` using its globally unique id."""
  deleteEventByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEventByNodeIdInput!
  ): DeleteEventPayload

  """Deletes a single `Event` using a unique key."""
  deleteEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEventInput!
  ): DeleteEventPayload

  """Deletes a single `Goal` using its globally unique id."""
  deleteGoalByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGoalByNodeIdInput!
  ): DeleteGoalPayload

  """Deletes a single `Goal` using a unique key."""
  deleteGoal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGoalInput!
  ): DeleteGoalPayload

  """Deletes a single `Proposal` using its globally unique id."""
  deleteProposalByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProposalByNodeIdInput!
  ): DeleteProposalPayload

  """Deletes a single `Proposal` using a unique key."""
  deleteProposal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProposalInput!
  ): DeleteProposalPayload

  """Deletes a single `Proposal` using a unique key."""
  deleteProposalById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProposalByIdInput!
  ): DeleteProposalPayload

  """Deletes a single `ProposalVoteplan` using its globally unique id."""
  deleteProposalVoteplanByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProposalVoteplanByNodeIdInput!
  ): DeleteProposalVoteplanPayload

  """Deletes a single `ProposalVoteplan` using a unique key."""
  deleteProposalVoteplan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProposalVoteplanInput!
  ): DeleteProposalVoteplanPayload

  """Deletes a single `RefinerySchemaHistory` using its globally unique id."""
  deleteRefinerySchemaHistoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRefinerySchemaHistoryByNodeIdInput!
  ): DeleteRefinerySchemaHistoryPayload

  """Deletes a single `RefinerySchemaHistory` using a unique key."""
  deleteRefinerySchemaHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRefinerySchemaHistoryInput!
  ): DeleteRefinerySchemaHistoryPayload

  """Deletes a single `Snapshot` using its globally unique id."""
  deleteSnapshotByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSnapshotByNodeIdInput!
  ): DeleteSnapshotPayload

  """Deletes a single `Snapshot` using a unique key."""
  deleteSnapshot(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSnapshotInput!
  ): DeleteSnapshotPayload

  """Deletes a single `Snapshot` using a unique key."""
  deleteSnapshotByEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSnapshotByEventInput!
  ): DeleteSnapshotPayload

  """Deletes a single `TallyCommittee` using its globally unique id."""
  deleteTallyCommitteeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTallyCommitteeByNodeIdInput!
  ): DeleteTallyCommitteePayload

  """Deletes a single `TallyCommittee` using a unique key."""
  deleteTallyCommittee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTallyCommitteeInput!
  ): DeleteTallyCommitteePayload

  """Deletes a single `TallyCommittee` using a unique key."""
  deleteTallyCommitteeByEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTallyCommitteeByEventInput!
  ): DeleteTallyCommitteePayload

  """Deletes a single `Vote` using its globally unique id."""
  deleteVoteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteByNodeIdInput!
  ): DeleteVotePayload

  """Deletes a single `Vote` using a unique key."""
  deleteVote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteInput!
  ): DeleteVotePayload

  """Deletes a single `VoteOption` using its globally unique id."""
  deleteVoteOptionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteOptionByNodeIdInput!
  ): DeleteVoteOptionPayload

  """Deletes a single `VoteOption` using a unique key."""
  deleteVoteOption(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteOptionInput!
  ): DeleteVoteOptionPayload

  """Deletes a single `VoteOption` using a unique key."""
  deleteVoteOptionByIdeaScale(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteOptionByIdeaScaleInput!
  ): DeleteVoteOptionPayload

  """Deletes a single `VoteOption` using a unique key."""
  deleteVoteOptionByChallenge(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteOptionByChallengeInput!
  ): DeleteVoteOptionPayload

  """Deletes a single `Voteplan` using its globally unique id."""
  deleteVoteplanByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteplanByNodeIdInput!
  ): DeleteVoteplanPayload

  """Deletes a single `Voteplan` using a unique key."""
  deleteVoteplan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteplanInput!
  ): DeleteVoteplanPayload

  """Deletes a single `Voteplan` using a unique key."""
  deleteVoteplanById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteplanByIdInput!
  ): DeleteVoteplanPayload

  """Deletes a single `VoteplanCategory` using its globally unique id."""
  deleteVoteplanCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteplanCategoryByNodeIdInput!
  ): DeleteVoteplanCategoryPayload

  """Deletes a single `VoteplanCategory` using a unique key."""
  deleteVoteplanCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoteplanCategoryInput!
  ): DeleteVoteplanCategoryPayload

  """Deletes a single `Voter` using its globally unique id."""
  deleteVoterByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoterByNodeIdInput!
  ): DeleteVoterPayload

  """Deletes a single `Voter` using a unique key."""
  deleteVoter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVoterInput!
  ): DeleteVoterPayload

  """Deletes a single `VotingGroup` using its globally unique id."""
  deleteVotingGroupByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVotingGroupByNodeIdInput!
  ): DeleteVotingGroupPayload

  """Deletes a single `VotingGroup` using a unique key."""
  deleteVotingGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVotingGroupInput!
  ): DeleteVotingGroupPayload

  """Deletes a single `VotingNode` using its globally unique id."""
  deleteVotingNodeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVotingNodeByNodeIdInput!
  ): DeleteVotingNodePayload

  """Deletes a single `VotingNode` using a unique key."""
  deleteVotingNode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVotingNodeInput!
  ): DeleteVotingNodePayload

  """
  Creates a JWT token that will securely identify a person and give them certain permissions. This token expires in 1 hours.
  """
  authenticate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AuthenticateInput!
  ): AuthenticatePayload

  """Registers a single admin user and creates an account."""
  registerAdmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RegisterAdminInput!
  ): RegisterAdminPayload
}

"""The output of our create `Challenge` mutation."""
type CreateChallengePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Challenge` that was created by this mutation."""
  challenge: Challenge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Challenge`."""
  eventByEvent: Event

  """
  Reads a single `ChallengeCategory` that is related to this `Challenge`.
  """
  challengeCategoryByCategory: ChallengeCategory

  """Reads a single `Currency` that is related to this `Challenge`."""
  currencyByRewardsCurrency: Currency

  """Reads a single `VoteOption` that is related to this `Challenge`."""
  voteOptionByVoteOptions: VoteOption

  """An edge for our `Challenge`. May be used by Relay 1."""
  challengeEdge(
    """The method to use when ordering `Challenge`."""
    orderBy: [ChallengesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChallengesEdge
}

"""All input for the create `Challenge` mutation."""
input CreateChallengeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Challenge` to be created by this mutation."""
  challenge: ChallengeInput!
}

"""An input for mutations affecting `Challenge`"""
input ChallengeInput {
  """Synthetic Unique Key"""
  rowId: Int

  """
  Event specific Challenge ID.
  Can be non-unique between events (Eg, Ideascale ID for challenge).
  """
  id: Int!

  """The specific Event ID this Challenge is part of."""
  event: Int!

  """
  What category of challenge is this.
  See the challenge_category table for allowed values.
  """
  category: String!

  """The  title of the challenge."""
  title: String!

  """Long form description of the challenge."""
  description: String!

  """The currency rewards values are represented as."""
  rewardsCurrency: String

  """The total reward pool to pay on this challenge to winning proposals."""
  rewardsTotal: BigInt

  """Not sure how this is different from rewards_total???"""
  proposersRewards: BigInt

  """The Vote Options applicable to all proposals in this challenge."""
  voteOptions: Int

  """
  Extra Data  for this challenge represented as JSON.
  "url"."challenge" is a URL for more info about the challenge.
  "highlights" is ???
  
  """
  extra: JSON
}

"""The output of our create `ChallengeCategory` mutation."""
type CreateChallengeCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ChallengeCategory` that was created by this mutation."""
  challengeCategory: ChallengeCategory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ChallengeCategory`. May be used by Relay 1."""
  challengeCategoryEdge(
    """The method to use when ordering `ChallengeCategory`."""
    orderBy: [ChallengeCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChallengeCategoriesEdge
}

"""All input for the create `ChallengeCategory` mutation."""
input CreateChallengeCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ChallengeCategory` to be created by this mutation."""
  challengeCategory: ChallengeCategoryInput!
}

"""An input for mutations affecting `ChallengeCategory`"""
input ChallengeCategoryInput {
  """The name of this challenge category."""
  name: String!

  """A Description of this kind of challenge category."""
  description: String
}

"""The output of our create `CommunityAdvisorsReview` mutation."""
type CreateCommunityAdvisorsReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CommunityAdvisorsReview` that was created by this mutation."""
  communityAdvisorsReview: CommunityAdvisorsReview

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Proposal` that is related to this `CommunityAdvisorsReview`.
  """
  proposal: Proposal

  """An edge for our `CommunityAdvisorsReview`. May be used by Relay 1."""
  communityAdvisorsReviewEdge(
    """The method to use when ordering `CommunityAdvisorsReview`."""
    orderBy: [CommunityAdvisorsReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommunityAdvisorsReviewsEdge
}

"""All input for the create `CommunityAdvisorsReview` mutation."""
input CreateCommunityAdvisorsReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CommunityAdvisorsReview` to be created by this mutation."""
  communityAdvisorsReview: CommunityAdvisorsReviewInput!
}

"""An input for mutations affecting `CommunityAdvisorsReview`"""
input CommunityAdvisorsReviewInput {
  """Synthetic Unique Key."""
  rowId: Int

  """The Proposal this review is for."""
  proposalId: Int!

  """Assessors Anonymized ID"""
  assessor: String!

  """The  numeric rating assigned to the proposal by the assessor."""
  impactAlignmentRatingGiven: Int

  """A note about why the impact rating was given."""
  impactAlignmentNote: String

  """The numeric feasibility rating given."""
  feasibilityRatingGiven: Int

  """A note about why the feasibility rating was given."""
  feasibilityNote: String

  """The numeric auditability rating given."""
  auditabilityRatingGiven: Int

  """A note about the auditability rating given."""
  auditabilityNote: String

  """
  Numeric  Measure of quality of this review according to veteran community advisors.
  """
  ranking: Int
}

"""The output of our create `Config` mutation."""
type CreateConfigPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Config` that was created by this mutation."""
  config: Config

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Config`. May be used by Relay 1."""
  configEdge(
    """The method to use when ordering `Config`."""
    orderBy: [ConfigsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConfigsEdge
}

"""All input for the create `Config` mutation."""
input CreateConfigInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Config` to be created by this mutation."""
  config: ConfigInput!
}

"""An input for mutations affecting `Config`"""
input ConfigInput {
  """
  Synthetic unique key.
  Always lookup using id.
  """
  rowId: Int

  """The name/id of the general config value/variable"""
  id: String!

  """
  2nd ID of the general config value.
  Must be defined, use "" if not required.
  """
  id2: String!

  """
  3rd ID of the general config value.
  Must be defined, use "" if not required.
  """
  id3: String!

  """The JSON value of the system variable id.id2.id3"""
  value: JSON
}

"""The output of our create `Contribution` mutation."""
type CreateContributionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Contribution` that was created by this mutation."""
  contribution: Contribution

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Snapshot` that is related to this `Contribution`."""
  snapshot: Snapshot

  """An edge for our `Contribution`. May be used by Relay 1."""
  contributionEdge(
    """The method to use when ordering `Contribution`."""
    orderBy: [ContributionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContributionsEdge
}

"""All input for the create `Contribution` mutation."""
input CreateContributionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Contribution` to be created by this mutation."""
  contribution: ContributionInput!
}

"""An input for mutations affecting `Contribution`"""
input ContributionInput {
  """Synthetic Unique Row Key"""
  rowId: BigInt

  """The voters Stake Public Key"""
  stakePublicKey: String!

  """The snapshot this contribution was recorded from."""
  snapshotId: Int!

  """The voting key.  If this is NULL it is the raw staked ADA."""
  votingKey: String

  """The weight this voting key gets of the total."""
  votingWeight: Int

  """The index from 0 of the keys in the delegation array."""
  votingKeyIdx: Int

  """
  The amount of ADA contributed to this voting key from the stake address
  """
  value: BigInt!

  """The group this contribution goes to."""
  votingGroup: String!

  """
  Currently Unused.  Should be the Stake Rewards address of the voter (currently unknown.)
  """
  rewardAddress: String
}

"""The output of our create `Currency` mutation."""
type CreateCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was created by this mutation."""
  currency: Currency

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the create `Currency` mutation."""
input CreateCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Currency` to be created by this mutation."""
  currency: CurrencyInput!
}

"""An input for mutations affecting `Currency`"""
input CurrencyInput {
  """The name of this currency type."""
  name: String!

  """A Description of this kind of currency type."""
  description: String
}

"""The output of our create `Event` mutation."""
type CreateEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was created by this mutation."""
  event: Event

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the create `Event` mutation."""
input CreateEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Event` to be created by this mutation."""
  event: EventInput!
}

"""An input for mutations affecting `Event`"""
input EventInput {
  """Synthetic Unique ID for each event."""
  rowId: Int

  """
  The name of the event.
  eg. "Fund9" or "SVE1"
  """
  name: String!

  """
  A detailed description of the purpose of the event.
  eg. the events "Goal".
  """
  description: String!

  """
  The Time (UTC) Registrations are taken from Cardano main net.
  Registrations after this date are not valid for voting on the event.
  NULL = Not yet defined or Not Applicable.
  """
  registrationSnapshotTime: Datetime

  """
  The Time (UTC) Registrations taken from Cardano main net are considered stable.
  This is not the Time of the Registration Snapshot,
  This is the time after which the registration snapshot will be stable.
  NULL = Not yet defined or Not Applicable.
  """
  snapshotStart: Datetime

  """
  The Minimum number of Lovelace staked at the time of snapshot, to be eligible to vote.
  NULL = Not yet defined.
  """
  votingPowerThreshold: BigInt
  maxVotingPowerPct: BigFloat

  """
  The time (UTC) the event starts.
  NULL = Not yet defined.
  """
  startTime: Datetime

  """
  The time (UTC) the event ends.
  NULL = Not yet defined.
  """
  endTime: Datetime

  """
  TODO.
  NULL = Not yet defined.
  """
  insightSharingStart: Datetime

  """
  The Time (UTC) proposals can start to be submitted for the event.
  NULL = Not yet defined, or Not applicable.
  """
  proposalSubmissionStart: Datetime

  """
  TODO.
  NULL = Not yet defined.
  """
  refineProposalsStart: Datetime

  """
  The Time (UTC) when all proposals must be finalized by.
  NULL = Not yet defined, or Not applicable.
  """
  finalizeProposalsStart: Datetime

  """
  The Time (UTC) when PA Assessors can start assessing proposals.
  NULL = Not yet defined, or Not applicable.
  """
  proposalAssessmentStart: Datetime

  """
  The Time (UTC) when vPA Assessors can start assessing assessments.
  NULL = Not yet defined, or Not applicable.
  """
  assessmentQaStart: Datetime

  """
  The earliest time that registered wallets with sufficient voting power can place votes in the event.
  NULL = Not yet defined.
  """
  votingStart: Datetime

  """
  The latest time that registered wallets with sufficient voting power can place votes in the event.
  NULL = Not yet defined.
  """
  votingEnd: Datetime

  """
  The latest time that tallying the event can complete by.
  NULL = Not yet defined.
  """
  tallyingEnd: Datetime

  """
  The copy of Block 0 used to start the Blockchain.
  NULL = Blockchain not started yet.
  """
  block0: String

  """
  The hash of block 0.
  NULL = Blockchain not started yet.
  """
  block0Hash: String

  """
  The size of the tally committee.
  0 = No Committee, and all votes are therefore public.
  """
  committeeSize: Int!

  """
  The minimum size of the tally committee to perform the tally.
  Must be <= `comittee_size`
  """
  committeeThreshold: Int!

  """
  Json Map defining event specific extra data.
  NULL = Not yet defined.
  "url"."results" = a results URL,
  "url"."survey" = a survey URL,
  others can be defined as required.
  """
  extra: JSON
}

"""The output of our create `Goal` mutation."""
type CreateGoalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Goal` that was created by this mutation."""
  goal: Goal

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Goal`."""
  event: Event

  """An edge for our `Goal`. May be used by Relay 1."""
  goalEdge(
    """The method to use when ordering `Goal`."""
    orderBy: [GoalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GoalsEdge
}

"""All input for the create `Goal` mutation."""
input CreateGoalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Goal` to be created by this mutation."""
  goal: GoalInput!
}

"""An input for mutations affecting `Goal`"""
input GoalInput {
  """Synthetic Unique Key."""
  id: Int

  """The ID of the event this goal belongs to."""
  eventId: Int!

  """The index specifying the order/priority of the goals."""
  idx: Int!

  """The description of this event goal."""
  name: String!
}

"""The output of our create `Proposal` mutation."""
type CreateProposalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Proposal` that was created by this mutation."""
  proposal: Proposal

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Challenge` that is related to this `Proposal`."""
  challengeByChallenge: Challenge

  """Reads a single `VoteOption` that is related to this `Proposal`."""
  voteOptionByBbVoteOptions: VoteOption

  """An edge for our `Proposal`. May be used by Relay 1."""
  proposalEdge(
    """The method to use when ordering `Proposal`."""
    orderBy: [ProposalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProposalsEdge
}

"""All input for the create `Proposal` mutation."""
input CreateProposalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Proposal` to be created by this mutation."""
  proposal: ProposalInput!
}

"""An input for mutations affecting `Proposal`"""
input ProposalInput {
  """Synthetic Unique Key"""
  rowId: Int

  """Actual Proposal Unique ID"""
  id: Int!

  """The Challenge this proposal falls under."""
  challenge: Int!

  """Brief title of the proposal."""
  title: String!

  """A Summary of the proposal to be implemented."""
  summary: String!
  category: String!

  """???"""
  publicKey: String!

  """How much funds (in the currency of the fund)"""
  funds: BigInt!

  """A URL with supporting information for the proposal."""
  url: String!

  """A URL link to relevant files supporting the proposal."""
  filesUrl: String!

  """The Impact score assigned to this proposal by the Assessors."""
  impactScore: BigInt!

  """
  Extra data about the proposal.
   The types of extra data are defined by the proposal type and are not enforced.
   Extra Fields for `native` challenges:
      NONE.
  
   Extra Fields for `simple` challenges:
      "solution" : <text> - The Solution to the challenge.
  
   Extra Fields for `community choice` challenge:
      "brief"      : <text> - Brief explanation of a proposal.
      "importance" : <text> - The importance of the proposal.
      "goal"       : <text> - The goal of the proposal is addressed to meet.
      "metrics"    : <text> - The metrics of the proposal or how success will be determined.
  """
  extra: JSON

  """The proposers name."""
  proposerName: String!

  """Contact details for the proposer."""
  proposerContact: String!

  """A URL with details of the proposer."""
  proposerUrl: String!

  """
  A freeform  string describing the proposers experience relating to their capability to implement the proposal.
  """
  proposerRelevantExperience: String!

  """
  The ID used by the voting ledger (bulletin board) to refer to this proposal.
  """
  bbProposalId: String

  """The selectable options by the voter."""
  bbVoteOptions: String
}

"""The output of our create `ProposalVoteplan` mutation."""
type CreateProposalVoteplanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProposalVoteplan` that was created by this mutation."""
  proposalVoteplan: ProposalVoteplan

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Proposal` that is related to this `ProposalVoteplan`."""
  proposal: Proposal

  """Reads a single `Voteplan` that is related to this `ProposalVoteplan`."""
  voteplan: Voteplan

  """An edge for our `ProposalVoteplan`. May be used by Relay 1."""
  proposalVoteplanEdge(
    """The method to use when ordering `ProposalVoteplan`."""
    orderBy: [ProposalVoteplansOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProposalVoteplansEdge
}

"""All input for the create `ProposalVoteplan` mutation."""
input CreateProposalVoteplanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProposalVoteplan` to be created by this mutation."""
  proposalVoteplan: ProposalVoteplanInput!
}

"""An input for mutations affecting `ProposalVoteplan`"""
input ProposalVoteplanInput {
  """Synthetic ID of this Voteplan/Proposal M-M relationship."""
  rowId: Int

  """The link to the Proposal primary key that links to this voteplan."""
  proposalId: Int

  """The link to the Voteplan primary key that links to this proposal."""
  voteplanId: Int

  """
  The Index with the voteplan used by the voting ledger/bulletin board that references this proposal.
  """
  bbProposalIndex: BigInt
}

"""The output of our create `RefinerySchemaHistory` mutation."""
type CreateRefinerySchemaHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RefinerySchemaHistory` that was created by this mutation."""
  refinerySchemaHistory: RefinerySchemaHistory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `RefinerySchemaHistory`. May be used by Relay 1."""
  refinerySchemaHistoryEdge(
    """The method to use when ordering `RefinerySchemaHistory`."""
    orderBy: [RefinerySchemaHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefinerySchemaHistoriesEdge
}

"""All input for the create `RefinerySchemaHistory` mutation."""
input CreateRefinerySchemaHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `RefinerySchemaHistory` to be created by this mutation."""
  refinerySchemaHistory: RefinerySchemaHistoryInput!
}

"""An input for mutations affecting `RefinerySchemaHistory`"""
input RefinerySchemaHistoryInput {
  version: Int!
  name: String
  appliedOn: String
  checksum: String
}

"""The output of our create `Snapshot` mutation."""
type CreateSnapshotPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Snapshot` that was created by this mutation."""
  snapshot: Snapshot

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Snapshot`."""
  eventByEvent: Event

  """An edge for our `Snapshot`. May be used by Relay 1."""
  snapshotEdge(
    """The method to use when ordering `Snapshot`."""
    orderBy: [SnapshotsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SnapshotsEdge
}

"""All input for the create `Snapshot` mutation."""
input CreateSnapshotInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Snapshot` to be created by this mutation."""
  snapshot: SnapshotInput!
}

"""An input for mutations affecting `Snapshot`"""
input SnapshotInput {
  rowId: Int

  """The event id this snapshot was for."""
  event: Int!

  """
  The time the snapshot was collected from dbsync
  (Should be the slot time the dbsync_snapshot_cmd was run against.)
  """
  asAt: Datetime!

  """
  The last time the snapshot was run
  (Should be the real time the snapshot was started.
  """
  lastUpdated: Datetime!

  """
  Is the snapshot Final?
  No more updates will occur to this record once set.
  """
  final: Boolean!

  """The name of the command run to collect the snapshot from dbsync."""
  dbsyncSnapshotCmd: String

  """
  The parameters passed to the command, each parameter is a key and its value is the value of the parameter.
  """
  dbsyncSnapshotParams: JSON

  """
  The raw json result stored as TEXT from the dbsync snapshot.
  (This is JSON data but we store as raw text to prevent any processing of it).
  """
  dbsyncSnapshotData: String

  """
  The latest drep data obtained from GVC, and used in this snapshot calculation.
  Should be in a form directly usable by the `catalyst_snapshot_cmd`
  """
  drepData: String

  """
  The actual name of the command run to produce the catalyst voting power snapshot.
  """
  catalystSnapshotCmd: String
  catalystSnapshotParams: JSON

  """
  The raw yaml result stored as TEXT from the catalyst snapshot calculation.
  (This is YAML data but we store as raw text to prevent any processing of it).
  """
  catalystSnapshotData: String
}

"""The output of our create `TallyCommittee` mutation."""
type CreateTallyCommitteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TallyCommittee` that was created by this mutation."""
  tallyCommittee: TallyCommittee

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `TallyCommittee`."""
  eventByEvent: Event

  """An edge for our `TallyCommittee`. May be used by Relay 1."""
  tallyCommitteeEdge(
    """The method to use when ordering `TallyCommittee`."""
    orderBy: [TallyCommitteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TallyCommitteesEdge
}

"""All input for the create `TallyCommittee` mutation."""
input CreateTallyCommitteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TallyCommittee` to be created by this mutation."""
  tallyCommittee: TallyCommitteeInput!
}

"""An input for mutations affecting `TallyCommittee`"""
input TallyCommitteeInput {
  """Unique ID for this committee member for this event."""
  rowId: Int

  """The event this committee member is for."""
  event: Int!
}

"""The output of our create `Vote` mutation."""
type CreateVotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Vote` that was created by this mutation."""
  vote: Vote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Vote`."""
  eventByEvent: Event

  """Reads a single `Voter` that is related to this `Vote`."""
  voterByVoter: Voter

  """Reads a single `Challenge` that is related to this `Vote`."""
  challengeByChallenge: Challenge

  """Reads a single `Proposal` that is related to this `Vote`."""
  proposalByChallengeAndProposal: Proposal

  """Reads a single `Proposal` that is related to this `Vote`."""
  proposalByProposal: Proposal

  """Reads a single `Voteplan` that is related to this `Vote`."""
  voteplanByVoteplan: Voteplan

  """An edge for our `Vote`. May be used by Relay 1."""
  voteEdge(
    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotesEdge
}

"""All input for the create `Vote` mutation."""
input CreateVoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Vote` to be created by this mutation."""
  vote: VoteInput!
}

"""An input for mutations affecting `Vote`"""
input VoteInput {
  rowId: BigInt
  event: Int

  """Unique ID of this Vote"""
  fragmentId: String

  """Reference to the Voter who cast the vote"""
  voter: Int!

  """Reference to the Challenge the vote was for."""
  challenge: Int!

  """
  Reference to the Proposal the vote was for.
  May be NULL if this vote covers ALL proposals in the challenge.
  """
  proposal: Int

  """The Voteplan this vote was cast in"""
  voteplan: Int!

  """When this vote was recorded as properly cast"""
  castAt: Datetime!

  """If a public vote, the choice of the vote, otherwise NULL."""
  choice: Int

  """The raw vote record."""
  rawFragment: String!
}

"""The output of our create `VoteOption` mutation."""
type CreateVoteOptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VoteOption` that was created by this mutation."""
  voteOption: VoteOption

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `VoteOption`. May be used by Relay 1."""
  voteOptionEdge(
    """The method to use when ordering `VoteOption`."""
    orderBy: [VoteOptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteOptionsEdge
}

"""All input for the create `VoteOption` mutation."""
input CreateVoteOptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `VoteOption` to be created by this mutation."""
  voteOption: VoteOptionInput!
}

"""An input for mutations affecting `VoteOption`"""
input VoteOptionInput {
  """Unique ID for each possible option set."""
  id: Int

  """How this vote option is represented in idea scale."""
  ideaScale: String

  """How the vote options is represented in the challenge."""
  challenge: String
}

"""The output of our create `Voteplan` mutation."""
type CreateVoteplanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Voteplan` that was created by this mutation."""
  voteplan: Voteplan

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Voteplan`."""
  event: Event

  """Reads a single `VoteplanCategory` that is related to this `Voteplan`."""
  voteplanCategoryByCategory: VoteplanCategory

  """Reads a single `VotingGroup` that is related to this `Voteplan`."""
  group: VotingGroup

  """An edge for our `Voteplan`. May be used by Relay 1."""
  voteplanEdge(
    """The method to use when ordering `Voteplan`."""
    orderBy: [VoteplansOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteplansEdge
}

"""All input for the create `Voteplan` mutation."""
input CreateVoteplanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Voteplan` to be created by this mutation."""
  voteplan: VoteplanInput!
}

"""An input for mutations affecting `Voteplan`"""
input VoteplanInput {
  """Synthetic Unique Key"""
  rowId: Int
  eventId: Int!

  """
  The ID of the Vote plan in the voting ledger/bulletin board.
  A Binary value encoded as hex.
  """
  id: String!

  """The kind of vote which can be cast on this vote plan."""
  category: String!

  """
  The public encryption key used.
  ONLY if required by the voteplan category.
  """
  encryptionKey: String

  """The identifier of voting power token used withing this plan."""
  groupId: Int
}

"""The output of our create `VoteplanCategory` mutation."""
type CreateVoteplanCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VoteplanCategory` that was created by this mutation."""
  voteplanCategory: VoteplanCategory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `VoteplanCategory`. May be used by Relay 1."""
  voteplanCategoryEdge(
    """The method to use when ordering `VoteplanCategory`."""
    orderBy: [VoteplanCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteplanCategoriesEdge
}

"""All input for the create `VoteplanCategory` mutation."""
input CreateVoteplanCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `VoteplanCategory` to be created by this mutation."""
  voteplanCategory: VoteplanCategoryInput!
}

"""An input for mutations affecting `VoteplanCategory`"""
input VoteplanCategoryInput {
  """The UNIQUE name of this voteplan category."""
  name: String!

  """Does this vote plan category require a public key."""
  publicKey: Boolean
}

"""The output of our create `Voter` mutation."""
type CreateVoterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Voter` that was created by this mutation."""
  voter: Voter

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Snapshot` that is related to this `Voter`."""
  snapshot: Snapshot

  """An edge for our `Voter`. May be used by Relay 1."""
  voterEdge(
    """The method to use when ordering `Voter`."""
    orderBy: [VotersOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotersEdge
}

"""All input for the create `Voter` mutation."""
input CreateVoterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Voter` to be created by this mutation."""
  voter: VoterInput!
}

"""An input for mutations affecting `Voter`"""
input VoterInput {
  rowId: BigInt

  """Either the voting key."""
  votingKey: String!

  """The ID of the snapshot this record belongs to."""
  snapshotId: Int!

  """The voter group the voter belongs to."""
  votingGroup: String!

  """Calculated Voting Power associated with this key."""
  votingPower: BigInt!
}

"""The output of our create `VotingGroup` mutation."""
type CreateVotingGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VotingGroup` that was created by this mutation."""
  votingGroup: VotingGroup

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `VotingGroup`."""
  event: Event

  """An edge for our `VotingGroup`. May be used by Relay 1."""
  votingGroupEdge(
    """The method to use when ordering `VotingGroup`."""
    orderBy: [VotingGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotingGroupsEdge
}

"""All input for the create `VotingGroup` mutation."""
input CreateVotingGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `VotingGroup` to be created by this mutation."""
  votingGroup: VotingGroupInput!
}

"""An input for mutations affecting `VotingGroup`"""
input VotingGroupInput {
  """Synthetic Unique Key."""
  rowId: Int

  """The ID of this voting group."""
  groupId: String!

  """The event this voting group belongs to."""
  eventId: Int!

  """The ID of the voting token used by this group."""
  tokenId: String
}

"""The output of our create `VotingNode` mutation."""
type CreateVotingNodePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VotingNode` that was created by this mutation."""
  votingNode: VotingNode

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `VotingNode`."""
  eventByEvent: Event

  """An edge for our `VotingNode`. May be used by Relay 1."""
  votingNodeEdge(
    """The method to use when ordering `VotingNode`."""
    orderBy: [VotingNodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotingNodesEdge
}

"""All input for the create `VotingNode` mutation."""
input CreateVotingNodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `VotingNode` to be created by this mutation."""
  votingNode: VotingNodeInput!
}

"""An input for mutations affecting `VotingNode`"""
input VotingNodeInput {
  """Unique hostname for the voting node."""
  hostname: String!

  """Unique event this node was configured for."""
  event: Int!

  """
  Public key from Ed25519 pair for the node.
  Used as consensus_leader_id when the node is a leader.
  """
  pubkey: String!

  """Secret key from Ed25519 pair for the node. Used as the node secret."""
  seckey: String!

  """
  Ed25519 secret key for the node.
  Used as the node p2p topology key.
  """
  netkey: String!
}

"""The output of our update `Challenge` mutation."""
type UpdateChallengePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Challenge` that was updated by this mutation."""
  challenge: Challenge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Challenge`."""
  eventByEvent: Event

  """
  Reads a single `ChallengeCategory` that is related to this `Challenge`.
  """
  challengeCategoryByCategory: ChallengeCategory

  """Reads a single `Currency` that is related to this `Challenge`."""
  currencyByRewardsCurrency: Currency

  """Reads a single `VoteOption` that is related to this `Challenge`."""
  voteOptionByVoteOptions: VoteOption

  """An edge for our `Challenge`. May be used by Relay 1."""
  challengeEdge(
    """The method to use when ordering `Challenge`."""
    orderBy: [ChallengesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChallengesEdge
}

"""All input for the `updateChallengeByNodeId` mutation."""
input UpdateChallengeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Challenge` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Challenge` being updated.
  """
  patch: ChallengePatch!
}

"""
Represents an update to a `Challenge`. Fields that are set will be updated.
"""
input ChallengePatch {
  """Synthetic Unique Key"""
  rowId: Int

  """
  Event specific Challenge ID.
  Can be non-unique between events (Eg, Ideascale ID for challenge).
  """
  id: Int

  """The specific Event ID this Challenge is part of."""
  event: Int

  """
  What category of challenge is this.
  See the challenge_category table for allowed values.
  """
  category: String

  """The  title of the challenge."""
  title: String

  """Long form description of the challenge."""
  description: String

  """The currency rewards values are represented as."""
  rewardsCurrency: String

  """The total reward pool to pay on this challenge to winning proposals."""
  rewardsTotal: BigInt

  """Not sure how this is different from rewards_total???"""
  proposersRewards: BigInt

  """The Vote Options applicable to all proposals in this challenge."""
  voteOptions: Int

  """
  Extra Data  for this challenge represented as JSON.
  "url"."challenge" is a URL for more info about the challenge.
  "highlights" is ???
  
  """
  extra: JSON
}

"""All input for the `updateChallenge` mutation."""
input UpdateChallengeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Challenge` being updated.
  """
  patch: ChallengePatch!

  """Synthetic Unique Key"""
  rowId: Int!
}

"""The output of our update `ChallengeCategory` mutation."""
type UpdateChallengeCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ChallengeCategory` that was updated by this mutation."""
  challengeCategory: ChallengeCategory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ChallengeCategory`. May be used by Relay 1."""
  challengeCategoryEdge(
    """The method to use when ordering `ChallengeCategory`."""
    orderBy: [ChallengeCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChallengeCategoriesEdge
}

"""All input for the `updateChallengeCategoryByNodeId` mutation."""
input UpdateChallengeCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ChallengeCategory` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ChallengeCategory` being updated.
  """
  patch: ChallengeCategoryPatch!
}

"""
Represents an update to a `ChallengeCategory`. Fields that are set will be updated.
"""
input ChallengeCategoryPatch {
  """The name of this challenge category."""
  name: String

  """A Description of this kind of challenge category."""
  description: String
}

"""All input for the `updateChallengeCategory` mutation."""
input UpdateChallengeCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ChallengeCategory` being updated.
  """
  patch: ChallengeCategoryPatch!

  """The name of this challenge category."""
  name: String!
}

"""The output of our update `CommunityAdvisorsReview` mutation."""
type UpdateCommunityAdvisorsReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CommunityAdvisorsReview` that was updated by this mutation."""
  communityAdvisorsReview: CommunityAdvisorsReview

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Proposal` that is related to this `CommunityAdvisorsReview`.
  """
  proposal: Proposal

  """An edge for our `CommunityAdvisorsReview`. May be used by Relay 1."""
  communityAdvisorsReviewEdge(
    """The method to use when ordering `CommunityAdvisorsReview`."""
    orderBy: [CommunityAdvisorsReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommunityAdvisorsReviewsEdge
}

"""All input for the `updateCommunityAdvisorsReviewByNodeId` mutation."""
input UpdateCommunityAdvisorsReviewByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CommunityAdvisorsReview` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CommunityAdvisorsReview` being updated.
  """
  patch: CommunityAdvisorsReviewPatch!
}

"""
Represents an update to a `CommunityAdvisorsReview`. Fields that are set will be updated.
"""
input CommunityAdvisorsReviewPatch {
  """Synthetic Unique Key."""
  rowId: Int

  """The Proposal this review is for."""
  proposalId: Int

  """Assessors Anonymized ID"""
  assessor: String

  """The  numeric rating assigned to the proposal by the assessor."""
  impactAlignmentRatingGiven: Int

  """A note about why the impact rating was given."""
  impactAlignmentNote: String

  """The numeric feasibility rating given."""
  feasibilityRatingGiven: Int

  """A note about why the feasibility rating was given."""
  feasibilityNote: String

  """The numeric auditability rating given."""
  auditabilityRatingGiven: Int

  """A note about the auditability rating given."""
  auditabilityNote: String

  """
  Numeric  Measure of quality of this review according to veteran community advisors.
  """
  ranking: Int
}

"""All input for the `updateCommunityAdvisorsReview` mutation."""
input UpdateCommunityAdvisorsReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CommunityAdvisorsReview` being updated.
  """
  patch: CommunityAdvisorsReviewPatch!

  """Synthetic Unique Key."""
  rowId: Int!
}

"""The output of our update `Config` mutation."""
type UpdateConfigPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Config` that was updated by this mutation."""
  config: Config

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Config`. May be used by Relay 1."""
  configEdge(
    """The method to use when ordering `Config`."""
    orderBy: [ConfigsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConfigsEdge
}

"""All input for the `updateConfigByNodeId` mutation."""
input UpdateConfigByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Config` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Config` being updated.
  """
  patch: ConfigPatch!
}

"""
Represents an update to a `Config`. Fields that are set will be updated.
"""
input ConfigPatch {
  """
  Synthetic unique key.
  Always lookup using id.
  """
  rowId: Int

  """The name/id of the general config value/variable"""
  id: String

  """
  2nd ID of the general config value.
  Must be defined, use "" if not required.
  """
  id2: String

  """
  3rd ID of the general config value.
  Must be defined, use "" if not required.
  """
  id3: String

  """The JSON value of the system variable id.id2.id3"""
  value: JSON
}

"""All input for the `updateConfig` mutation."""
input UpdateConfigInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Config` being updated.
  """
  patch: ConfigPatch!

  """
  Synthetic unique key.
  Always lookup using id.
  """
  rowId: Int!
}

"""The output of our update `Contribution` mutation."""
type UpdateContributionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Contribution` that was updated by this mutation."""
  contribution: Contribution

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Snapshot` that is related to this `Contribution`."""
  snapshot: Snapshot

  """An edge for our `Contribution`. May be used by Relay 1."""
  contributionEdge(
    """The method to use when ordering `Contribution`."""
    orderBy: [ContributionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContributionsEdge
}

"""All input for the `updateContributionByNodeId` mutation."""
input UpdateContributionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Contribution` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Contribution` being updated.
  """
  patch: ContributionPatch!
}

"""
Represents an update to a `Contribution`. Fields that are set will be updated.
"""
input ContributionPatch {
  """Synthetic Unique Row Key"""
  rowId: BigInt

  """The voters Stake Public Key"""
  stakePublicKey: String

  """The snapshot this contribution was recorded from."""
  snapshotId: Int

  """The voting key.  If this is NULL it is the raw staked ADA."""
  votingKey: String

  """The weight this voting key gets of the total."""
  votingWeight: Int

  """The index from 0 of the keys in the delegation array."""
  votingKeyIdx: Int

  """
  The amount of ADA contributed to this voting key from the stake address
  """
  value: BigInt

  """The group this contribution goes to."""
  votingGroup: String

  """
  Currently Unused.  Should be the Stake Rewards address of the voter (currently unknown.)
  """
  rewardAddress: String
}

"""All input for the `updateContribution` mutation."""
input UpdateContributionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Contribution` being updated.
  """
  patch: ContributionPatch!

  """Synthetic Unique Row Key"""
  rowId: BigInt!
}

"""The output of our update `Currency` mutation."""
type UpdateCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was updated by this mutation."""
  currency: Currency

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the `updateCurrencyByNodeId` mutation."""
input UpdateCurrencyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Currency` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Currency` being updated.
  """
  patch: CurrencyPatch!
}

"""
Represents an update to a `Currency`. Fields that are set will be updated.
"""
input CurrencyPatch {
  """The name of this currency type."""
  name: String

  """A Description of this kind of currency type."""
  description: String
}

"""All input for the `updateCurrency` mutation."""
input UpdateCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Currency` being updated.
  """
  patch: CurrencyPatch!

  """The name of this currency type."""
  name: String!
}

"""The output of our update `Event` mutation."""
type UpdateEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was updated by this mutation."""
  event: Event

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the `updateEventByNodeId` mutation."""
input UpdateEventByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Event` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Event` being updated.
  """
  patch: EventPatch!
}

"""
Represents an update to a `Event`. Fields that are set will be updated.
"""
input EventPatch {
  """Synthetic Unique ID for each event."""
  rowId: Int

  """
  The name of the event.
  eg. "Fund9" or "SVE1"
  """
  name: String

  """
  A detailed description of the purpose of the event.
  eg. the events "Goal".
  """
  description: String

  """
  The Time (UTC) Registrations are taken from Cardano main net.
  Registrations after this date are not valid for voting on the event.
  NULL = Not yet defined or Not Applicable.
  """
  registrationSnapshotTime: Datetime

  """
  The Time (UTC) Registrations taken from Cardano main net are considered stable.
  This is not the Time of the Registration Snapshot,
  This is the time after which the registration snapshot will be stable.
  NULL = Not yet defined or Not Applicable.
  """
  snapshotStart: Datetime

  """
  The Minimum number of Lovelace staked at the time of snapshot, to be eligible to vote.
  NULL = Not yet defined.
  """
  votingPowerThreshold: BigInt
  maxVotingPowerPct: BigFloat

  """
  The time (UTC) the event starts.
  NULL = Not yet defined.
  """
  startTime: Datetime

  """
  The time (UTC) the event ends.
  NULL = Not yet defined.
  """
  endTime: Datetime

  """
  TODO.
  NULL = Not yet defined.
  """
  insightSharingStart: Datetime

  """
  The Time (UTC) proposals can start to be submitted for the event.
  NULL = Not yet defined, or Not applicable.
  """
  proposalSubmissionStart: Datetime

  """
  TODO.
  NULL = Not yet defined.
  """
  refineProposalsStart: Datetime

  """
  The Time (UTC) when all proposals must be finalized by.
  NULL = Not yet defined, or Not applicable.
  """
  finalizeProposalsStart: Datetime

  """
  The Time (UTC) when PA Assessors can start assessing proposals.
  NULL = Not yet defined, or Not applicable.
  """
  proposalAssessmentStart: Datetime

  """
  The Time (UTC) when vPA Assessors can start assessing assessments.
  NULL = Not yet defined, or Not applicable.
  """
  assessmentQaStart: Datetime

  """
  The earliest time that registered wallets with sufficient voting power can place votes in the event.
  NULL = Not yet defined.
  """
  votingStart: Datetime

  """
  The latest time that registered wallets with sufficient voting power can place votes in the event.
  NULL = Not yet defined.
  """
  votingEnd: Datetime

  """
  The latest time that tallying the event can complete by.
  NULL = Not yet defined.
  """
  tallyingEnd: Datetime

  """
  The copy of Block 0 used to start the Blockchain.
  NULL = Blockchain not started yet.
  """
  block0: String

  """
  The hash of block 0.
  NULL = Blockchain not started yet.
  """
  block0Hash: String

  """
  The size of the tally committee.
  0 = No Committee, and all votes are therefore public.
  """
  committeeSize: Int

  """
  The minimum size of the tally committee to perform the tally.
  Must be <= `comittee_size`
  """
  committeeThreshold: Int

  """
  Json Map defining event specific extra data.
  NULL = Not yet defined.
  "url"."results" = a results URL,
  "url"."survey" = a survey URL,
  others can be defined as required.
  """
  extra: JSON
}

"""All input for the `updateEvent` mutation."""
input UpdateEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Event` being updated.
  """
  patch: EventPatch!

  """Synthetic Unique ID for each event."""
  rowId: Int!
}

"""The output of our update `Goal` mutation."""
type UpdateGoalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Goal` that was updated by this mutation."""
  goal: Goal

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Goal`."""
  event: Event

  """An edge for our `Goal`. May be used by Relay 1."""
  goalEdge(
    """The method to use when ordering `Goal`."""
    orderBy: [GoalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GoalsEdge
}

"""All input for the `updateGoalByNodeId` mutation."""
input UpdateGoalByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Goal` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Goal` being updated.
  """
  patch: GoalPatch!
}

"""Represents an update to a `Goal`. Fields that are set will be updated."""
input GoalPatch {
  """Synthetic Unique Key."""
  id: Int

  """The ID of the event this goal belongs to."""
  eventId: Int

  """The index specifying the order/priority of the goals."""
  idx: Int

  """The description of this event goal."""
  name: String
}

"""All input for the `updateGoal` mutation."""
input UpdateGoalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Goal` being updated.
  """
  patch: GoalPatch!

  """Synthetic Unique Key."""
  id: Int!
}

"""The output of our update `Proposal` mutation."""
type UpdateProposalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Proposal` that was updated by this mutation."""
  proposal: Proposal

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Challenge` that is related to this `Proposal`."""
  challengeByChallenge: Challenge

  """Reads a single `VoteOption` that is related to this `Proposal`."""
  voteOptionByBbVoteOptions: VoteOption

  """An edge for our `Proposal`. May be used by Relay 1."""
  proposalEdge(
    """The method to use when ordering `Proposal`."""
    orderBy: [ProposalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProposalsEdge
}

"""All input for the `updateProposalByNodeId` mutation."""
input UpdateProposalByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Proposal` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Proposal` being updated.
  """
  patch: ProposalPatch!
}

"""
Represents an update to a `Proposal`. Fields that are set will be updated.
"""
input ProposalPatch {
  """Synthetic Unique Key"""
  rowId: Int

  """Actual Proposal Unique ID"""
  id: Int

  """The Challenge this proposal falls under."""
  challenge: Int

  """Brief title of the proposal."""
  title: String

  """A Summary of the proposal to be implemented."""
  summary: String
  category: String

  """???"""
  publicKey: String

  """How much funds (in the currency of the fund)"""
  funds: BigInt

  """A URL with supporting information for the proposal."""
  url: String

  """A URL link to relevant files supporting the proposal."""
  filesUrl: String

  """The Impact score assigned to this proposal by the Assessors."""
  impactScore: BigInt

  """
  Extra data about the proposal.
   The types of extra data are defined by the proposal type and are not enforced.
   Extra Fields for `native` challenges:
      NONE.
  
   Extra Fields for `simple` challenges:
      "solution" : <text> - The Solution to the challenge.
  
   Extra Fields for `community choice` challenge:
      "brief"      : <text> - Brief explanation of a proposal.
      "importance" : <text> - The importance of the proposal.
      "goal"       : <text> - The goal of the proposal is addressed to meet.
      "metrics"    : <text> - The metrics of the proposal or how success will be determined.
  """
  extra: JSON

  """The proposers name."""
  proposerName: String

  """Contact details for the proposer."""
  proposerContact: String

  """A URL with details of the proposer."""
  proposerUrl: String

  """
  A freeform  string describing the proposers experience relating to their capability to implement the proposal.
  """
  proposerRelevantExperience: String

  """
  The ID used by the voting ledger (bulletin board) to refer to this proposal.
  """
  bbProposalId: String

  """The selectable options by the voter."""
  bbVoteOptions: String
}

"""All input for the `updateProposal` mutation."""
input UpdateProposalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Proposal` being updated.
  """
  patch: ProposalPatch!

  """Synthetic Unique Key"""
  rowId: Int!
}

"""All input for the `updateProposalById` mutation."""
input UpdateProposalByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Proposal` being updated.
  """
  patch: ProposalPatch!

  """Actual Proposal Unique ID"""
  id: Int!
}

"""The output of our update `ProposalVoteplan` mutation."""
type UpdateProposalVoteplanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProposalVoteplan` that was updated by this mutation."""
  proposalVoteplan: ProposalVoteplan

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Proposal` that is related to this `ProposalVoteplan`."""
  proposal: Proposal

  """Reads a single `Voteplan` that is related to this `ProposalVoteplan`."""
  voteplan: Voteplan

  """An edge for our `ProposalVoteplan`. May be used by Relay 1."""
  proposalVoteplanEdge(
    """The method to use when ordering `ProposalVoteplan`."""
    orderBy: [ProposalVoteplansOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProposalVoteplansEdge
}

"""All input for the `updateProposalVoteplanByNodeId` mutation."""
input UpdateProposalVoteplanByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProposalVoteplan` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ProposalVoteplan` being updated.
  """
  patch: ProposalVoteplanPatch!
}

"""
Represents an update to a `ProposalVoteplan`. Fields that are set will be updated.
"""
input ProposalVoteplanPatch {
  """Synthetic ID of this Voteplan/Proposal M-M relationship."""
  rowId: Int

  """The link to the Proposal primary key that links to this voteplan."""
  proposalId: Int

  """The link to the Voteplan primary key that links to this proposal."""
  voteplanId: Int

  """
  The Index with the voteplan used by the voting ledger/bulletin board that references this proposal.
  """
  bbProposalIndex: BigInt
}

"""All input for the `updateProposalVoteplan` mutation."""
input UpdateProposalVoteplanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ProposalVoteplan` being updated.
  """
  patch: ProposalVoteplanPatch!

  """Synthetic ID of this Voteplan/Proposal M-M relationship."""
  rowId: Int!
}

"""The output of our update `RefinerySchemaHistory` mutation."""
type UpdateRefinerySchemaHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RefinerySchemaHistory` that was updated by this mutation."""
  refinerySchemaHistory: RefinerySchemaHistory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `RefinerySchemaHistory`. May be used by Relay 1."""
  refinerySchemaHistoryEdge(
    """The method to use when ordering `RefinerySchemaHistory`."""
    orderBy: [RefinerySchemaHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefinerySchemaHistoriesEdge
}

"""All input for the `updateRefinerySchemaHistoryByNodeId` mutation."""
input UpdateRefinerySchemaHistoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `RefinerySchemaHistory` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `RefinerySchemaHistory` being updated.
  """
  patch: RefinerySchemaHistoryPatch!
}

"""
Represents an update to a `RefinerySchemaHistory`. Fields that are set will be updated.
"""
input RefinerySchemaHistoryPatch {
  version: Int
  name: String
  appliedOn: String
  checksum: String
}

"""All input for the `updateRefinerySchemaHistory` mutation."""
input UpdateRefinerySchemaHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `RefinerySchemaHistory` being updated.
  """
  patch: RefinerySchemaHistoryPatch!
  version: Int!
}

"""The output of our update `Snapshot` mutation."""
type UpdateSnapshotPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Snapshot` that was updated by this mutation."""
  snapshot: Snapshot

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Snapshot`."""
  eventByEvent: Event

  """An edge for our `Snapshot`. May be used by Relay 1."""
  snapshotEdge(
    """The method to use when ordering `Snapshot`."""
    orderBy: [SnapshotsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SnapshotsEdge
}

"""All input for the `updateSnapshotByNodeId` mutation."""
input UpdateSnapshotByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Snapshot` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Snapshot` being updated.
  """
  patch: SnapshotPatch!
}

"""
Represents an update to a `Snapshot`. Fields that are set will be updated.
"""
input SnapshotPatch {
  rowId: Int

  """The event id this snapshot was for."""
  event: Int

  """
  The time the snapshot was collected from dbsync
  (Should be the slot time the dbsync_snapshot_cmd was run against.)
  """
  asAt: Datetime

  """
  The last time the snapshot was run
  (Should be the real time the snapshot was started.
  """
  lastUpdated: Datetime

  """
  Is the snapshot Final?
  No more updates will occur to this record once set.
  """
  final: Boolean

  """The name of the command run to collect the snapshot from dbsync."""
  dbsyncSnapshotCmd: String

  """
  The parameters passed to the command, each parameter is a key and its value is the value of the parameter.
  """
  dbsyncSnapshotParams: JSON

  """
  The raw json result stored as TEXT from the dbsync snapshot.
  (This is JSON data but we store as raw text to prevent any processing of it).
  """
  dbsyncSnapshotData: String

  """
  The latest drep data obtained from GVC, and used in this snapshot calculation.
  Should be in a form directly usable by the `catalyst_snapshot_cmd`
  """
  drepData: String

  """
  The actual name of the command run to produce the catalyst voting power snapshot.
  """
  catalystSnapshotCmd: String
  catalystSnapshotParams: JSON

  """
  The raw yaml result stored as TEXT from the catalyst snapshot calculation.
  (This is YAML data but we store as raw text to prevent any processing of it).
  """
  catalystSnapshotData: String
}

"""All input for the `updateSnapshot` mutation."""
input UpdateSnapshotInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Snapshot` being updated.
  """
  patch: SnapshotPatch!
  rowId: Int!
}

"""All input for the `updateSnapshotByEvent` mutation."""
input UpdateSnapshotByEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Snapshot` being updated.
  """
  patch: SnapshotPatch!

  """The event id this snapshot was for."""
  event: Int!
}

"""The output of our update `TallyCommittee` mutation."""
type UpdateTallyCommitteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TallyCommittee` that was updated by this mutation."""
  tallyCommittee: TallyCommittee

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `TallyCommittee`."""
  eventByEvent: Event

  """An edge for our `TallyCommittee`. May be used by Relay 1."""
  tallyCommitteeEdge(
    """The method to use when ordering `TallyCommittee`."""
    orderBy: [TallyCommitteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TallyCommitteesEdge
}

"""All input for the `updateTallyCommitteeByNodeId` mutation."""
input UpdateTallyCommitteeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TallyCommittee` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TallyCommittee` being updated.
  """
  patch: TallyCommitteePatch!
}

"""
Represents an update to a `TallyCommittee`. Fields that are set will be updated.
"""
input TallyCommitteePatch {
  """Unique ID for this committee member for this event."""
  rowId: Int

  """The event this committee member is for."""
  event: Int
}

"""All input for the `updateTallyCommittee` mutation."""
input UpdateTallyCommitteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TallyCommittee` being updated.
  """
  patch: TallyCommitteePatch!

  """Unique ID for this committee member for this event."""
  rowId: Int!
}

"""All input for the `updateTallyCommitteeByEvent` mutation."""
input UpdateTallyCommitteeByEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TallyCommittee` being updated.
  """
  patch: TallyCommitteePatch!

  """The event this committee member is for."""
  event: Int!
}

"""The output of our update `Vote` mutation."""
type UpdateVotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Vote` that was updated by this mutation."""
  vote: Vote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Vote`."""
  eventByEvent: Event

  """Reads a single `Voter` that is related to this `Vote`."""
  voterByVoter: Voter

  """Reads a single `Challenge` that is related to this `Vote`."""
  challengeByChallenge: Challenge

  """Reads a single `Proposal` that is related to this `Vote`."""
  proposalByChallengeAndProposal: Proposal

  """Reads a single `Proposal` that is related to this `Vote`."""
  proposalByProposal: Proposal

  """Reads a single `Voteplan` that is related to this `Vote`."""
  voteplanByVoteplan: Voteplan

  """An edge for our `Vote`. May be used by Relay 1."""
  voteEdge(
    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotesEdge
}

"""All input for the `updateVoteByNodeId` mutation."""
input UpdateVoteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Vote` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Vote` being updated.
  """
  patch: VotePatch!
}

"""Represents an update to a `Vote`. Fields that are set will be updated."""
input VotePatch {
  rowId: BigInt
  event: Int

  """Unique ID of this Vote"""
  fragmentId: String

  """Reference to the Voter who cast the vote"""
  voter: Int

  """Reference to the Challenge the vote was for."""
  challenge: Int

  """
  Reference to the Proposal the vote was for.
  May be NULL if this vote covers ALL proposals in the challenge.
  """
  proposal: Int

  """The Voteplan this vote was cast in"""
  voteplan: Int

  """When this vote was recorded as properly cast"""
  castAt: Datetime

  """If a public vote, the choice of the vote, otherwise NULL."""
  choice: Int

  """The raw vote record."""
  rawFragment: String
}

"""All input for the `updateVote` mutation."""
input UpdateVoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Vote` being updated.
  """
  patch: VotePatch!
  rowId: BigInt!
}

"""The output of our update `VoteOption` mutation."""
type UpdateVoteOptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VoteOption` that was updated by this mutation."""
  voteOption: VoteOption

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `VoteOption`. May be used by Relay 1."""
  voteOptionEdge(
    """The method to use when ordering `VoteOption`."""
    orderBy: [VoteOptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteOptionsEdge
}

"""All input for the `updateVoteOptionByNodeId` mutation."""
input UpdateVoteOptionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `VoteOption` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `VoteOption` being updated.
  """
  patch: VoteOptionPatch!
}

"""
Represents an update to a `VoteOption`. Fields that are set will be updated.
"""
input VoteOptionPatch {
  """Unique ID for each possible option set."""
  id: Int

  """How this vote option is represented in idea scale."""
  ideaScale: String

  """How the vote options is represented in the challenge."""
  challenge: String
}

"""All input for the `updateVoteOption` mutation."""
input UpdateVoteOptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `VoteOption` being updated.
  """
  patch: VoteOptionPatch!

  """Unique ID for each possible option set."""
  id: Int!
}

"""All input for the `updateVoteOptionByIdeaScale` mutation."""
input UpdateVoteOptionByIdeaScaleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `VoteOption` being updated.
  """
  patch: VoteOptionPatch!

  """How this vote option is represented in idea scale."""
  ideaScale: String!
}

"""All input for the `updateVoteOptionByChallenge` mutation."""
input UpdateVoteOptionByChallengeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `VoteOption` being updated.
  """
  patch: VoteOptionPatch!

  """How the vote options is represented in the challenge."""
  challenge: String!
}

"""The output of our update `Voteplan` mutation."""
type UpdateVoteplanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Voteplan` that was updated by this mutation."""
  voteplan: Voteplan

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Voteplan`."""
  event: Event

  """Reads a single `VoteplanCategory` that is related to this `Voteplan`."""
  voteplanCategoryByCategory: VoteplanCategory

  """Reads a single `VotingGroup` that is related to this `Voteplan`."""
  group: VotingGroup

  """An edge for our `Voteplan`. May be used by Relay 1."""
  voteplanEdge(
    """The method to use when ordering `Voteplan`."""
    orderBy: [VoteplansOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteplansEdge
}

"""All input for the `updateVoteplanByNodeId` mutation."""
input UpdateVoteplanByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Voteplan` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Voteplan` being updated.
  """
  patch: VoteplanPatch!
}

"""
Represents an update to a `Voteplan`. Fields that are set will be updated.
"""
input VoteplanPatch {
  """Synthetic Unique Key"""
  rowId: Int
  eventId: Int

  """
  The ID of the Vote plan in the voting ledger/bulletin board.
  A Binary value encoded as hex.
  """
  id: String

  """The kind of vote which can be cast on this vote plan."""
  category: String

  """
  The public encryption key used.
  ONLY if required by the voteplan category.
  """
  encryptionKey: String

  """The identifier of voting power token used withing this plan."""
  groupId: Int
}

"""All input for the `updateVoteplan` mutation."""
input UpdateVoteplanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Voteplan` being updated.
  """
  patch: VoteplanPatch!

  """Synthetic Unique Key"""
  rowId: Int!
}

"""All input for the `updateVoteplanById` mutation."""
input UpdateVoteplanByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Voteplan` being updated.
  """
  patch: VoteplanPatch!

  """
  The ID of the Vote plan in the voting ledger/bulletin board.
  A Binary value encoded as hex.
  """
  id: String!
}

"""The output of our update `VoteplanCategory` mutation."""
type UpdateVoteplanCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VoteplanCategory` that was updated by this mutation."""
  voteplanCategory: VoteplanCategory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `VoteplanCategory`. May be used by Relay 1."""
  voteplanCategoryEdge(
    """The method to use when ordering `VoteplanCategory`."""
    orderBy: [VoteplanCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteplanCategoriesEdge
}

"""All input for the `updateVoteplanCategoryByNodeId` mutation."""
input UpdateVoteplanCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `VoteplanCategory` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `VoteplanCategory` being updated.
  """
  patch: VoteplanCategoryPatch!
}

"""
Represents an update to a `VoteplanCategory`. Fields that are set will be updated.
"""
input VoteplanCategoryPatch {
  """The UNIQUE name of this voteplan category."""
  name: String

  """Does this vote plan category require a public key."""
  publicKey: Boolean
}

"""All input for the `updateVoteplanCategory` mutation."""
input UpdateVoteplanCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `VoteplanCategory` being updated.
  """
  patch: VoteplanCategoryPatch!

  """The UNIQUE name of this voteplan category."""
  name: String!
}

"""The output of our update `Voter` mutation."""
type UpdateVoterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Voter` that was updated by this mutation."""
  voter: Voter

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Snapshot` that is related to this `Voter`."""
  snapshot: Snapshot

  """An edge for our `Voter`. May be used by Relay 1."""
  voterEdge(
    """The method to use when ordering `Voter`."""
    orderBy: [VotersOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotersEdge
}

"""All input for the `updateVoterByNodeId` mutation."""
input UpdateVoterByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Voter` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Voter` being updated.
  """
  patch: VoterPatch!
}

"""
Represents an update to a `Voter`. Fields that are set will be updated.
"""
input VoterPatch {
  rowId: BigInt

  """Either the voting key."""
  votingKey: String

  """The ID of the snapshot this record belongs to."""
  snapshotId: Int

  """The voter group the voter belongs to."""
  votingGroup: String

  """Calculated Voting Power associated with this key."""
  votingPower: BigInt
}

"""All input for the `updateVoter` mutation."""
input UpdateVoterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Voter` being updated.
  """
  patch: VoterPatch!
  rowId: BigInt!
}

"""The output of our update `VotingGroup` mutation."""
type UpdateVotingGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VotingGroup` that was updated by this mutation."""
  votingGroup: VotingGroup

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `VotingGroup`."""
  event: Event

  """An edge for our `VotingGroup`. May be used by Relay 1."""
  votingGroupEdge(
    """The method to use when ordering `VotingGroup`."""
    orderBy: [VotingGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotingGroupsEdge
}

"""All input for the `updateVotingGroupByNodeId` mutation."""
input UpdateVotingGroupByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `VotingGroup` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `VotingGroup` being updated.
  """
  patch: VotingGroupPatch!
}

"""
Represents an update to a `VotingGroup`. Fields that are set will be updated.
"""
input VotingGroupPatch {
  """Synthetic Unique Key."""
  rowId: Int

  """The ID of this voting group."""
  groupId: String

  """The event this voting group belongs to."""
  eventId: Int

  """The ID of the voting token used by this group."""
  tokenId: String
}

"""All input for the `updateVotingGroup` mutation."""
input UpdateVotingGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `VotingGroup` being updated.
  """
  patch: VotingGroupPatch!

  """Synthetic Unique Key."""
  rowId: Int!
}

"""The output of our update `VotingNode` mutation."""
type UpdateVotingNodePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VotingNode` that was updated by this mutation."""
  votingNode: VotingNode

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `VotingNode`."""
  eventByEvent: Event

  """An edge for our `VotingNode`. May be used by Relay 1."""
  votingNodeEdge(
    """The method to use when ordering `VotingNode`."""
    orderBy: [VotingNodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotingNodesEdge
}

"""All input for the `updateVotingNodeByNodeId` mutation."""
input UpdateVotingNodeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `VotingNode` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `VotingNode` being updated.
  """
  patch: VotingNodePatch!
}

"""
Represents an update to a `VotingNode`. Fields that are set will be updated.
"""
input VotingNodePatch {
  """Unique hostname for the voting node."""
  hostname: String

  """Unique event this node was configured for."""
  event: Int

  """
  Public key from Ed25519 pair for the node.
  Used as consensus_leader_id when the node is a leader.
  """
  pubkey: String

  """Secret key from Ed25519 pair for the node. Used as the node secret."""
  seckey: String

  """
  Ed25519 secret key for the node.
  Used as the node p2p topology key.
  """
  netkey: String
}

"""All input for the `updateVotingNode` mutation."""
input UpdateVotingNodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `VotingNode` being updated.
  """
  patch: VotingNodePatch!

  """Unique hostname for the voting node."""
  hostname: String!

  """Unique event this node was configured for."""
  event: Int!
}

"""The output of our delete `Challenge` mutation."""
type DeleteChallengePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Challenge` that was deleted by this mutation."""
  challenge: Challenge
  deletedChallengeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Challenge`."""
  eventByEvent: Event

  """
  Reads a single `ChallengeCategory` that is related to this `Challenge`.
  """
  challengeCategoryByCategory: ChallengeCategory

  """Reads a single `Currency` that is related to this `Challenge`."""
  currencyByRewardsCurrency: Currency

  """Reads a single `VoteOption` that is related to this `Challenge`."""
  voteOptionByVoteOptions: VoteOption

  """An edge for our `Challenge`. May be used by Relay 1."""
  challengeEdge(
    """The method to use when ordering `Challenge`."""
    orderBy: [ChallengesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChallengesEdge
}

"""All input for the `deleteChallengeByNodeId` mutation."""
input DeleteChallengeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Challenge` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteChallenge` mutation."""
input DeleteChallengeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic Unique Key"""
  rowId: Int!
}

"""The output of our delete `ChallengeCategory` mutation."""
type DeleteChallengeCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ChallengeCategory` that was deleted by this mutation."""
  challengeCategory: ChallengeCategory
  deletedChallengeCategoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ChallengeCategory`. May be used by Relay 1."""
  challengeCategoryEdge(
    """The method to use when ordering `ChallengeCategory`."""
    orderBy: [ChallengeCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChallengeCategoriesEdge
}

"""All input for the `deleteChallengeCategoryByNodeId` mutation."""
input DeleteChallengeCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ChallengeCategory` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteChallengeCategory` mutation."""
input DeleteChallengeCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The name of this challenge category."""
  name: String!
}

"""The output of our delete `CommunityAdvisorsReview` mutation."""
type DeleteCommunityAdvisorsReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CommunityAdvisorsReview` that was deleted by this mutation."""
  communityAdvisorsReview: CommunityAdvisorsReview
  deletedCommunityAdvisorsReviewNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Proposal` that is related to this `CommunityAdvisorsReview`.
  """
  proposal: Proposal

  """An edge for our `CommunityAdvisorsReview`. May be used by Relay 1."""
  communityAdvisorsReviewEdge(
    """The method to use when ordering `CommunityAdvisorsReview`."""
    orderBy: [CommunityAdvisorsReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommunityAdvisorsReviewsEdge
}

"""All input for the `deleteCommunityAdvisorsReviewByNodeId` mutation."""
input DeleteCommunityAdvisorsReviewByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CommunityAdvisorsReview` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCommunityAdvisorsReview` mutation."""
input DeleteCommunityAdvisorsReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic Unique Key."""
  rowId: Int!
}

"""The output of our delete `Config` mutation."""
type DeleteConfigPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Config` that was deleted by this mutation."""
  config: Config
  deletedConfigNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Config`. May be used by Relay 1."""
  configEdge(
    """The method to use when ordering `Config`."""
    orderBy: [ConfigsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConfigsEdge
}

"""All input for the `deleteConfigByNodeId` mutation."""
input DeleteConfigByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Config` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteConfig` mutation."""
input DeleteConfigInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Synthetic unique key.
  Always lookup using id.
  """
  rowId: Int!
}

"""The output of our delete `Contribution` mutation."""
type DeleteContributionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Contribution` that was deleted by this mutation."""
  contribution: Contribution
  deletedContributionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Snapshot` that is related to this `Contribution`."""
  snapshot: Snapshot

  """An edge for our `Contribution`. May be used by Relay 1."""
  contributionEdge(
    """The method to use when ordering `Contribution`."""
    orderBy: [ContributionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContributionsEdge
}

"""All input for the `deleteContributionByNodeId` mutation."""
input DeleteContributionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Contribution` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteContribution` mutation."""
input DeleteContributionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic Unique Row Key"""
  rowId: BigInt!
}

"""The output of our delete `Currency` mutation."""
type DeleteCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was deleted by this mutation."""
  currency: Currency
  deletedCurrencyNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the `deleteCurrencyByNodeId` mutation."""
input DeleteCurrencyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Currency` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCurrency` mutation."""
input DeleteCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The name of this currency type."""
  name: String!
}

"""The output of our delete `Event` mutation."""
type DeleteEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was deleted by this mutation."""
  event: Event
  deletedEventNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the `deleteEventByNodeId` mutation."""
input DeleteEventByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Event` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteEvent` mutation."""
input DeleteEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic Unique ID for each event."""
  rowId: Int!
}

"""The output of our delete `Goal` mutation."""
type DeleteGoalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Goal` that was deleted by this mutation."""
  goal: Goal
  deletedGoalNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Goal`."""
  event: Event

  """An edge for our `Goal`. May be used by Relay 1."""
  goalEdge(
    """The method to use when ordering `Goal`."""
    orderBy: [GoalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GoalsEdge
}

"""All input for the `deleteGoalByNodeId` mutation."""
input DeleteGoalByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Goal` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGoal` mutation."""
input DeleteGoalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic Unique Key."""
  id: Int!
}

"""The output of our delete `Proposal` mutation."""
type DeleteProposalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Proposal` that was deleted by this mutation."""
  proposal: Proposal
  deletedProposalNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Challenge` that is related to this `Proposal`."""
  challengeByChallenge: Challenge

  """Reads a single `VoteOption` that is related to this `Proposal`."""
  voteOptionByBbVoteOptions: VoteOption

  """An edge for our `Proposal`. May be used by Relay 1."""
  proposalEdge(
    """The method to use when ordering `Proposal`."""
    orderBy: [ProposalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProposalsEdge
}

"""All input for the `deleteProposalByNodeId` mutation."""
input DeleteProposalByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Proposal` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProposal` mutation."""
input DeleteProposalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic Unique Key"""
  rowId: Int!
}

"""All input for the `deleteProposalById` mutation."""
input DeleteProposalByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Actual Proposal Unique ID"""
  id: Int!
}

"""The output of our delete `ProposalVoteplan` mutation."""
type DeleteProposalVoteplanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProposalVoteplan` that was deleted by this mutation."""
  proposalVoteplan: ProposalVoteplan
  deletedProposalVoteplanNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Proposal` that is related to this `ProposalVoteplan`."""
  proposal: Proposal

  """Reads a single `Voteplan` that is related to this `ProposalVoteplan`."""
  voteplan: Voteplan

  """An edge for our `ProposalVoteplan`. May be used by Relay 1."""
  proposalVoteplanEdge(
    """The method to use when ordering `ProposalVoteplan`."""
    orderBy: [ProposalVoteplansOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProposalVoteplansEdge
}

"""All input for the `deleteProposalVoteplanByNodeId` mutation."""
input DeleteProposalVoteplanByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProposalVoteplan` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProposalVoteplan` mutation."""
input DeleteProposalVoteplanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic ID of this Voteplan/Proposal M-M relationship."""
  rowId: Int!
}

"""The output of our delete `RefinerySchemaHistory` mutation."""
type DeleteRefinerySchemaHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RefinerySchemaHistory` that was deleted by this mutation."""
  refinerySchemaHistory: RefinerySchemaHistory
  deletedRefinerySchemaHistoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `RefinerySchemaHistory`. May be used by Relay 1."""
  refinerySchemaHistoryEdge(
    """The method to use when ordering `RefinerySchemaHistory`."""
    orderBy: [RefinerySchemaHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefinerySchemaHistoriesEdge
}

"""All input for the `deleteRefinerySchemaHistoryByNodeId` mutation."""
input DeleteRefinerySchemaHistoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `RefinerySchemaHistory` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRefinerySchemaHistory` mutation."""
input DeleteRefinerySchemaHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  version: Int!
}

"""The output of our delete `Snapshot` mutation."""
type DeleteSnapshotPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Snapshot` that was deleted by this mutation."""
  snapshot: Snapshot
  deletedSnapshotNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Snapshot`."""
  eventByEvent: Event

  """An edge for our `Snapshot`. May be used by Relay 1."""
  snapshotEdge(
    """The method to use when ordering `Snapshot`."""
    orderBy: [SnapshotsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SnapshotsEdge
}

"""All input for the `deleteSnapshotByNodeId` mutation."""
input DeleteSnapshotByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Snapshot` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSnapshot` mutation."""
input DeleteSnapshotInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""All input for the `deleteSnapshotByEvent` mutation."""
input DeleteSnapshotByEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The event id this snapshot was for."""
  event: Int!
}

"""The output of our delete `TallyCommittee` mutation."""
type DeleteTallyCommitteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TallyCommittee` that was deleted by this mutation."""
  tallyCommittee: TallyCommittee
  deletedTallyCommitteeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `TallyCommittee`."""
  eventByEvent: Event

  """An edge for our `TallyCommittee`. May be used by Relay 1."""
  tallyCommitteeEdge(
    """The method to use when ordering `TallyCommittee`."""
    orderBy: [TallyCommitteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TallyCommitteesEdge
}

"""All input for the `deleteTallyCommitteeByNodeId` mutation."""
input DeleteTallyCommitteeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TallyCommittee` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTallyCommittee` mutation."""
input DeleteTallyCommitteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Unique ID for this committee member for this event."""
  rowId: Int!
}

"""All input for the `deleteTallyCommitteeByEvent` mutation."""
input DeleteTallyCommitteeByEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The event this committee member is for."""
  event: Int!
}

"""The output of our delete `Vote` mutation."""
type DeleteVotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Vote` that was deleted by this mutation."""
  vote: Vote
  deletedVoteNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Vote`."""
  eventByEvent: Event

  """Reads a single `Voter` that is related to this `Vote`."""
  voterByVoter: Voter

  """Reads a single `Challenge` that is related to this `Vote`."""
  challengeByChallenge: Challenge

  """Reads a single `Proposal` that is related to this `Vote`."""
  proposalByChallengeAndProposal: Proposal

  """Reads a single `Proposal` that is related to this `Vote`."""
  proposalByProposal: Proposal

  """Reads a single `Voteplan` that is related to this `Vote`."""
  voteplanByVoteplan: Voteplan

  """An edge for our `Vote`. May be used by Relay 1."""
  voteEdge(
    """The method to use when ordering `Vote`."""
    orderBy: [VotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotesEdge
}

"""All input for the `deleteVoteByNodeId` mutation."""
input DeleteVoteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Vote` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVote` mutation."""
input DeleteVoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: BigInt!
}

"""The output of our delete `VoteOption` mutation."""
type DeleteVoteOptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VoteOption` that was deleted by this mutation."""
  voteOption: VoteOption
  deletedVoteOptionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `VoteOption`. May be used by Relay 1."""
  voteOptionEdge(
    """The method to use when ordering `VoteOption`."""
    orderBy: [VoteOptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteOptionsEdge
}

"""All input for the `deleteVoteOptionByNodeId` mutation."""
input DeleteVoteOptionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `VoteOption` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVoteOption` mutation."""
input DeleteVoteOptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Unique ID for each possible option set."""
  id: Int!
}

"""All input for the `deleteVoteOptionByIdeaScale` mutation."""
input DeleteVoteOptionByIdeaScaleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """How this vote option is represented in idea scale."""
  ideaScale: String!
}

"""All input for the `deleteVoteOptionByChallenge` mutation."""
input DeleteVoteOptionByChallengeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """How the vote options is represented in the challenge."""
  challenge: String!
}

"""The output of our delete `Voteplan` mutation."""
type DeleteVoteplanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Voteplan` that was deleted by this mutation."""
  voteplan: Voteplan
  deletedVoteplanNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Voteplan`."""
  event: Event

  """Reads a single `VoteplanCategory` that is related to this `Voteplan`."""
  voteplanCategoryByCategory: VoteplanCategory

  """Reads a single `VotingGroup` that is related to this `Voteplan`."""
  group: VotingGroup

  """An edge for our `Voteplan`. May be used by Relay 1."""
  voteplanEdge(
    """The method to use when ordering `Voteplan`."""
    orderBy: [VoteplansOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteplansEdge
}

"""All input for the `deleteVoteplanByNodeId` mutation."""
input DeleteVoteplanByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Voteplan` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVoteplan` mutation."""
input DeleteVoteplanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic Unique Key"""
  rowId: Int!
}

"""All input for the `deleteVoteplanById` mutation."""
input DeleteVoteplanByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The ID of the Vote plan in the voting ledger/bulletin board.
  A Binary value encoded as hex.
  """
  id: String!
}

"""The output of our delete `VoteplanCategory` mutation."""
type DeleteVoteplanCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VoteplanCategory` that was deleted by this mutation."""
  voteplanCategory: VoteplanCategory
  deletedVoteplanCategoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `VoteplanCategory`. May be used by Relay 1."""
  voteplanCategoryEdge(
    """The method to use when ordering `VoteplanCategory`."""
    orderBy: [VoteplanCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VoteplanCategoriesEdge
}

"""All input for the `deleteVoteplanCategoryByNodeId` mutation."""
input DeleteVoteplanCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `VoteplanCategory` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVoteplanCategory` mutation."""
input DeleteVoteplanCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The UNIQUE name of this voteplan category."""
  name: String!
}

"""The output of our delete `Voter` mutation."""
type DeleteVoterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Voter` that was deleted by this mutation."""
  voter: Voter
  deletedVoterNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Snapshot` that is related to this `Voter`."""
  snapshot: Snapshot

  """An edge for our `Voter`. May be used by Relay 1."""
  voterEdge(
    """The method to use when ordering `Voter`."""
    orderBy: [VotersOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotersEdge
}

"""All input for the `deleteVoterByNodeId` mutation."""
input DeleteVoterByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Voter` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVoter` mutation."""
input DeleteVoterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: BigInt!
}

"""The output of our delete `VotingGroup` mutation."""
type DeleteVotingGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VotingGroup` that was deleted by this mutation."""
  votingGroup: VotingGroup
  deletedVotingGroupNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `VotingGroup`."""
  event: Event

  """An edge for our `VotingGroup`. May be used by Relay 1."""
  votingGroupEdge(
    """The method to use when ordering `VotingGroup`."""
    orderBy: [VotingGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotingGroupsEdge
}

"""All input for the `deleteVotingGroupByNodeId` mutation."""
input DeleteVotingGroupByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `VotingGroup` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVotingGroup` mutation."""
input DeleteVotingGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Synthetic Unique Key."""
  rowId: Int!
}

"""The output of our delete `VotingNode` mutation."""
type DeleteVotingNodePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `VotingNode` that was deleted by this mutation."""
  votingNode: VotingNode
  deletedVotingNodeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `VotingNode`."""
  eventByEvent: Event

  """An edge for our `VotingNode`. May be used by Relay 1."""
  votingNodeEdge(
    """The method to use when ordering `VotingNode`."""
    orderBy: [VotingNodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): VotingNodesEdge
}

"""All input for the `deleteVotingNodeByNodeId` mutation."""
input DeleteVotingNodeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `VotingNode` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVotingNode` mutation."""
input DeleteVotingNodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Unique hostname for the voting node."""
  hostname: String!

  """Unique event this node was configured for."""
  event: Int!
}

"""The output of our `authenticate` mutation."""
type AuthenticatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  jwtToken: JwtToken

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
which securely represents claims between two parties.
"""
scalar JwtToken

"""All input for the `authenticate` mutation."""
input AuthenticateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: String!
  password: String!
}

"""The output of our `registerAdmin` mutation."""
type RegisterAdminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  adminAccount: AdminAccount

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `registerAdmin` mutation."""
input RegisterAdminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  role: String
}
