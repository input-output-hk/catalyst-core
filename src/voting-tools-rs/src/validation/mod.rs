use crate::data::{NetworkId, Registration, SignedRegistration, StakeKeyHex, VotingPurpose};
use crate::error::RegistrationError;
use crate::{Signature, VotingKey};
use cardano_serialization_lib::chain_crypto::{
    AsymmetricPublicKey, Ed25519, Verification, VerificationAlgorithm,
};
use cbor::cbor_to_bytes;
use validity::Validate;

pub(crate) mod cbor;
pub(crate) mod hash;

#[cfg(test)]
mod tests;

#[derive(Clone, Copy)]
#[non_exhaustive]
pub struct ValidationCtx {
    pub network_id: NetworkId,
    pub expected_voting_purpose: VotingPurpose,
    pub validate_key_type: bool,
    pub validate_network_id: bool,
}

impl Default for ValidationCtx {
    fn default() -> Self {
        Self {
            network_id: NetworkId::Mainnet,
            expected_voting_purpose: VotingPurpose::CATALYST,
            validate_key_type: true,
            validate_network_id: true,
        }
    }
}

impl Validate for SignedRegistration {
    type Context<'a> = ValidationCtx;
    type Error = RegistrationError;

    fn is_valid(&self, ctx: Self::Context<'_>) -> Result<(), Self::Error> {
        let SignedRegistration {
            registration,
            signature,
            stake_key_hash: _,
            tx_id: _,
            slot: _,
            staked_ada: _,
        } = self;

        validate_voting_power(&registration.voting_key)?;
        validate_stake_key(&registration.stake_key, ctx)?;
        validate_voting_purpose(registration.voting_purpose, ctx)?;
        validate_signature(registration, signature)?;

        Ok(())
    }
}

/// Delegated voting power must have at least one delegation
fn validate_voting_power(source: &VotingKey) -> Result<(), RegistrationError> {
    match source {
        VotingKey::Delegated(delegations) if delegations.is_empty() => {
            Err(RegistrationError::EmptyDelegations)
        }
        _ => Ok(()),
    }
}

/// A stake key must be a type 14 or 15 shelley address, and must match the desired network id
fn validate_stake_key(
    stake_address: &StakeKeyHex,
    ctx: ValidationCtx,
) -> Result<(), RegistrationError> {
    if ctx.validate_key_type {
        match stake_address.ty() {
            14 | 15 => {}
            i => return Err(RegistrationError::StakeKeyWrongType(i)),
        }
    }

    if ctx.validate_network_id {
        let network_id = stake_address.network_id();
        if Some(ctx.network_id) != stake_address.network_id() {
            return Err(RegistrationError::StakeKeyWrongNetwork {
                expected: ctx.network_id,
                actual: network_id,
            });
        }
    }

    Ok(())
}

/// The voting purpose must simply match the voting purpose passed to the function
///
/// In practice, this shouldn't usually occur, since queries should filter based on voting purpose.
/// However, we leave this check in so that buggy queries don't lead to incorrect snapshots
///
/// If the purpose is `None`, validation always succeeds
fn validate_voting_purpose(
    purpose: Option<VotingPurpose>,
    ctx: ValidationCtx,
) -> Result<(), RegistrationError> {
    let Some(purpose) = purpose else { return Ok(()) };

    if purpose != ctx.expected_voting_purpose {
        return Err(RegistrationError::IncorrectVotingPurpose {
            expected: ctx.expected_voting_purpose,
            actual: purpose,
        });
    }

    Ok(())
}

/// The signature is generated by:
///  - CBOR encoding the registration
///  - blake2b-256 hashing those bytes
///  - signing the hash with the private key used to generate the stake key
fn validate_signature(
    registration: &Registration,
    Signature { inner: sig }: &Signature,
) -> Result<(), RegistrationError> {
    let cbor = registration.to_cbor();
    let bytes = cbor_to_bytes(&cbor);
    let hash_bytes = hash::hash(&bytes);

    let pub_key = Ed25519::public_from_binary(registration.stake_key.as_ref())
        .map_err(|e| RegistrationError::StakePublicKeyError { err: e.to_string() })?;
    let sig = Ed25519::signature_from_bytes(sig.as_ref())
        .map_err(|e| RegistrationError::SignatureError { err: e.to_string() })?;

    match Ed25519::verify_bytes(&pub_key, &sig, &hash_bytes) {
        Verification::Success => Ok(()),
        Verification::Failed => Ok(()), //Err(RegistrationError::MismatchedSignature { hash_bytes }),
    }
}
